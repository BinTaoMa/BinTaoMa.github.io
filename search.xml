<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACM算法总结</title>
    <url>/2024/02/17/ACM%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>1.一串数字转字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">stringstream aq;</span><br><span class="line">aq&lt;&lt;a;</span><br><span class="line">aq&gt;&gt;s;<span class="comment">//s = aq.str();</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s;</span><br><span class="line"><span class="type">int</span> sum=s.<span class="built_in">length</span>() ;</span><br><span class="line">cout&lt;&lt;sum;</span><br></pre></td></tr></table></figure>

<p>2.求一句英文句子中每个单词有几个字母</p>
<pre><code>string s;
int a, sum=0;
getline(cin, s);//输入一句，不会被空格阻断
stringstream ss;
ss.clear();
ss.str(s);
while(ss &gt;&gt; s)
&#123;
    cout&lt;&lt;s.length() &lt;&lt;endl;
&#125;
</code></pre>
<p>3.万能模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;//万能头</span><br><span class="line">#pragma GCC optimize(2)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt;PII; //pair</span><br><span class="line">typedef unsigned long long ull;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int M=2010;</span><br><span class="line">const int INF=0x3f3f3f3f;//最大值</span><br><span class="line">const int mod=1e9+7;</span><br><span class="line">const int N=2e5+10;</span><br><span class="line">int dx[4]=&#123;0,1,0,-1&#125;;</span><br><span class="line">int dy[4]=&#123;-1,0,1,0&#125;;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">		//只用cin&gt;&gt;,加速</span><br><span class="line">        ios_base::sync_with_stdio(0);</span><br><span class="line">        cin.tie(0);</span><br><span class="line">        cout.tie(0);</span><br><span class="line">        //文件操作</span><br><span class="line">        freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">        int t;cin&gt;&gt;t;</span><br><span class="line">        while(t--)solve();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.最小公倍数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最小公倍数=a*b/最大公因数</span><br><span class="line"></span><br><span class="line">二分要先大于目标值</span><br><span class="line"></span><br><span class="line">并查集学习网址：https://blog.csdn.net/the_ZED/article/details/105126583?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164318091316780269847701%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164318091316780269847701&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-105126583.pc_search_result_cache&amp;utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&amp;spm=1018.2226.3001.4187</span><br></pre></td></tr></table></figure>

<p>5.四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">round()//函数</span><br><span class="line">(int)(a*1.0/b+0.5)</span><br></pre></td></tr></table></figure>

<p>6.去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[10];</span><br><span class="line">int start=unique(a,a+10)-a;</span><br></pre></td></tr></table></figure>

<p>7.位数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num;</span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line">cout&lt;&lt;setw(5)&lt;&lt;setfill(&#x27;2&#x27;)&lt;&lt;num&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>8.lc  sort（）排序定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(words.begin(),words.end(),[&amp;](string&amp; a, string &amp;b)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>9.else注意数值是否需要恢复初始化</p>
<p>10.n&amp;(1&lt;&lt;i)是将左移i位的1与n进行按位与，即为保留n的第i位，其余位置零</p>
<p>11.一维数组 邻接表 <a href="https://www.bilibili.com/video/BV14o4y1d7vv?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV14o4y1d7vv?spm_id_from=333.337.search-card.all.click</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e6;</span><br><span class="line">int h[maxn], ne[maxn], idx, e[maxn];</span><br><span class="line">void add(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    ne[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    memset(h, -1, sizeof h); //初始化邻接表</span><br><span class="line">    int n, m, u, v, temp = 0;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add(u, v);</span><br><span class="line">        if (i == 1)</span><br><span class="line">            temp = u;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = h[i]; j != -1; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; e[j] &lt;&lt; endl;</span><br><span class="line">            // 这是倒着输出，第一次输出的是，一个的最后位置之后往前递推</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.小数位输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;res&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>13.排列组合</p>
<p><a href="https://zhuanlan.zhihu.com/p/41855459">https://zhuanlan.zhihu.com/p/41855459</a></p>
<p>14.第一个大于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (<span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">1</span>) - a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 第一个大于等于1的元素是1，下标是0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (<span class="built_in">upper_bound</span>(a, a + <span class="number">5</span>, <span class="number">2</span>) - a) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 第一个大于2的元素是3，下标是1</span></span><br></pre></td></tr></table></figure>



<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r1-l1&gt;<span class="number">0.00001</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dll mid=(r1+l1)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(test(mid)*test(l1)&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r1=mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l1=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>,l1);</span><br><span class="line"><span class="comment">//l1和r1没区别</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r )/ <span class="number">2</span>;  </span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">		&#123;</span><br><span class="line">			ans = mid;  <span class="comment">// 这里需要保证 check()函数是找最佳值的位置的。</span></span><br><span class="line">						<span class="comment">//  这个位置已经满足一个位置了，再往mid - 1位置找看是否还有更佳位置</span></span><br><span class="line">			l = mid+ <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			r = mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br><span class="line">	<span class="comment">//答案是ans 或者返回l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;b.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">	int a[10];</span><br><span class="line">	for(int i=0;i&lt;10;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=10;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;找最靠前的值：&quot;&lt;&lt;endl;</span><br><span class="line">	int l=0,r=9;</span><br><span class="line">	while(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r&gt;&gt;1;</span><br><span class="line">		if(a[mid]&gt;=10)r=mid;</span><br><span class="line">		else l=mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;找最靠后的：&quot;&lt;&lt;endl;</span><br><span class="line">	l=0;r=9;</span><br><span class="line">	while(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r+1&gt;&gt;1;</span><br><span class="line">		if(a[mid]&lt;=10)l=mid;</span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lcm(int a, int b) &#123; return a * b / gcd(a, b); &#125;    最小公倍数</span><br><span class="line"></span><br><span class="line">int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125; 最大公约数</span><br></pre></td></tr></table></figure>

<h2 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h2><p>2021蓝桥javaB路径</p>
<p><a href="https://blog.csdn.net/qq_43196686/article/details/115836954">https://blog.csdn.net/qq_43196686/article/details/115836954</a></p>
<p>（耗时极大）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int min(int a, int b) &#123; return a &lt; b ? a : b; &#125;</span><br><span class="line">int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line">int lcm(int a, int b) &#123; return a * b / gcd(a, b); &#125;</span><br><span class="line"></span><br><span class="line">const int N = 2021;</span><br><span class="line">int num[N + 1][N + 1];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i+1; j &lt;= min(i+21,N); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i][j] = lcm(i, j);</span><br><span class="line">            num[j][i] = lcm(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int k = 1; k &lt;= N; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i][k] == 0)</span><br><span class="line">                continue;</span><br><span class="line">            for (int j = 1; j &lt;= N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (num[k][j] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                else if (num[i][j] == 0 || (num[i][j] &gt; num[i][k] + num[k][j]))</span><br><span class="line">                    num[i][j] = num[i][k] + num[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num[1][2021] &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra求最短路"><a href="#Dijkstra求最短路" class="headerlink" title="Dijkstra求最短路"></a>Dijkstra求最短路</h2><p><a href="https://www.acwing.com/problem/content/description/851/">https://www.acwing.com/problem/content/description/851/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int min(int a, int b) &#123; return a &lt; b ? a : b; &#125;</span><br><span class="line">int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;</span><br><span class="line">int lcm(int a, int b) &#123; return a * b / gcd(a, b); &#125;</span><br><span class="line">int edges[550][550];</span><br><span class="line">int dist[550];    //到出发点的距离</span><br><span class="line">int visited[550]; //所有点是否被丢弃</span><br><span class="line">int n, m;</span><br><span class="line">int dijkstra(int n1, int m1)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = -1;</span><br><span class="line">        dist[1] = 0;</span><br><span class="line">        for (int j = 1; j &lt;= n1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!visited[j] &amp;&amp; (index == -1 || dist[j] &lt; dist[index]))</span><br><span class="line">            &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = 1;</span><br><span class="line">        for (int j = 1; j &lt;= n1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dist[index] + edges[index][j] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[index] + edges[index][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dist[n1] == 0x3f3f3f3f)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return dist[n1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(edges, 0x3f, sizeof(edges));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edges[a][b] = edges[a][b] &gt; c ? c : edges[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dist, 0x3f, sizeof(dist));</span><br><span class="line">    memset(visited, 0, sizeof(visited));</span><br><span class="line">    cout &lt;&lt; dijkstra(n, m) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int test(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)res=(res*a)%c;</span><br><span class="line">        a=(a*a)%c;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;test(2,5,10)&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩陣快速冪"><a href="#矩陣快速冪" class="headerlink" title="矩陣快速冪"></a>矩陣快速冪</h2><p>单个横行和竖行的矩阵值为O，相当于乘法里的1；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod=1000000009;</span><br><span class="line">struct st</span><br><span class="line">&#123;</span><br><span class="line">	ll aa[2][2];</span><br><span class="line">&#125;;</span><br><span class="line">st mul(st x,st y)</span><br><span class="line">&#123;</span><br><span class="line">	st c;</span><br><span class="line">	memset(c.aa,0,sizeof(c.aa));</span><br><span class="line">	for(int i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0;j&lt;2;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int k=0;k&lt;2;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				c.aa[i][j]=(c.aa[i][j]+x.aa[i][k]*y.aa[k][j])%mod;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll test(ll a)</span><br><span class="line">&#123;</span><br><span class="line">	st base,base1;</span><br><span class="line">	memset(base.aa,0,sizeof(base.aa));</span><br><span class="line">	memset(base1.aa,0,sizeof(base1.aa));</span><br><span class="line">	for(int i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		base.aa[i][i]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	base1.aa[0][0]=base1.aa[0][1]=base1.aa[1][0]=1;</span><br><span class="line">	while(a)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a&amp;1)base=mul(base,base1);</span><br><span class="line">		base1=mul(base1,base1);</span><br><span class="line">		a&gt;&gt;=1;</span><br><span class="line">	&#125;</span><br><span class="line">	return base.aa[0][1];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll num;</span><br><span class="line">	cin&gt;&gt;num;</span><br><span class="line">	cout&lt;&lt;test(num)&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a><a href="https://vjudge.net/problem/51Nod-2659">并查集</a></h2><p><a href="https://vjudge.net/contest/479411#problem/F">https://vjudge.net/contest/479411#problem/F</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">4using namespace std;</span><br><span class="line">const int maxn=10e6+1;</span><br><span class="line">int a[maxn];</span><br><span class="line">int b[maxn];</span><br><span class="line">void init(int num)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int key)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[key]==key)return key;</span><br><span class="line">    else return a[key]=find(a[key]);</span><br><span class="line">&#125;</span><br><span class="line">void unit(int x1,int y1)</span><br><span class="line">&#123;</span><br><span class="line">    int xx1=find(x1);</span><br><span class="line">    int yy1=find(y1);</span><br><span class="line">    if(xx1!=yy1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[xx1]=yy1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init(n);</span><br><span class="line">    int a1,b1,c1;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a1&gt;&gt;b1&gt;&gt;c1;</span><br><span class="line">        if(a1==1)</span><br><span class="line">        &#123;</span><br><span class="line">            unit(b1,c1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a1==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(b1)!=find(c1))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><a href="https://vjudge.net/contest/479411#problem/J">https://vjudge.net/contest/479411#problem/J</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 101;</span><br><span class="line">int lin[maxn][maxn];</span><br><span class="line">int ss[maxn];</span><br><span class="line">int value[maxn];</span><br><span class="line">int a, b, m, n;</span><br><span class="line">queue&lt;int&gt; qq;</span><br><span class="line">void TP()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= a; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (lin[i][j] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                ss[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = 1;</span><br><span class="line">        while (ss[k] != 0)</span><br><span class="line">            k++;</span><br><span class="line">        value[i] = k;</span><br><span class="line">        ss[k] = -1;</span><br><span class="line">        for (int j = 1; j &lt;= a; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (lin[k][j] == 1)</span><br><span class="line">                ss[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!(a + b))</span><br><span class="line">            break;</span><br><span class="line">        memset(ss, 0, sizeof(ss));</span><br><span class="line">        memset(lin, 0, sizeof(lin));</span><br><span class="line">        memset(value, 0, sizeof(value));</span><br><span class="line">        for (int i = 0; i &lt; b; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">            if (i != b)</span><br><span class="line">                lin[m][n] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        TP();</span><br><span class="line">        for (int i = 1; i &lt;= a; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; value[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs简单例题"><a href="#bfs简单例题" class="headerlink" title="bfs简单例题"></a>bfs简单例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn= 100001;</span><br><span class="line">bool ha[maxn];</span><br><span class="line">int pl[maxn];</span><br><span class="line">queue&lt;int&gt; qq;</span><br><span class="line">int bfs(int a1,int b1)</span><br><span class="line">&#123;</span><br><span class="line">    qq.push(a1);</span><br><span class="line">    ha[a1]=true;</span><br><span class="line">    int next=0;</span><br><span class="line">    while(qq.size())</span><br><span class="line">    &#123;</span><br><span class="line">        int temp=qq.front();</span><br><span class="line">        qq.pop();</span><br><span class="line">        for(int i=0;i&lt;3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==0)next=temp-1;</span><br><span class="line">            else if(i==1)next=temp+1;</span><br><span class="line">            else next=temp*2;</span><br><span class="line">            if(next&lt;0||next&gt;=maxn)continue;</span><br><span class="line">            if(!ha[next])</span><br><span class="line">            &#123;</span><br><span class="line">                qq.push(next);</span><br><span class="line">                ha[next]=true;</span><br><span class="line">                pl[next]=pl[temp]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(next==b1)return pl[b1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    if(a&gt;=b)</span><br><span class="line">    cout&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">    cout&lt;&lt;bfs(a,b)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs简单例题-1"><a href="#bfs简单例题-1" class="headerlink" title="bfs简单例题"></a>bfs简单例题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=<span class="number">99999</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sx,sy,fx,fy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> xx,<span class="type">int</span> yy,<span class="type">int</span> ss):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy),<span class="built_in">step</span>(ss)&#123; &#125;<span class="comment">//可以使下面可以创建一个结点直接使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//比如说node(1,1,1)就可以直接使用,而不加这个的话会报错</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//判断可以通过的条件</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m&amp;&amp;vis[x][y]==<span class="number">0</span>&amp;&amp;a[x][y]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//没有越界,且没被遍历,且不是墙</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  vis[x][y]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">node</span>(x,y,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  node now=q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(now.x+<span class="number">1</span>&gt;n||now.y+<span class="number">1</span>&gt;m||now.x<span class="number">-1</span>&lt;<span class="number">1</span>||now.y<span class="number">-1</span>&lt;<span class="number">1</span>)<span class="comment">//判断下一步是否可以走出去</span></span><br><span class="line"></span><br><span class="line">      ans=<span class="built_in">min</span>(ans,now.step);<span class="comment">//最短路的判断</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nx=now.x+dir[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ny=now.y+dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(nx,ny))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx,ny,now.step+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      sx=i;</span><br><span class="line"></span><br><span class="line">      sy=j;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bfs</span>(sx,sy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ans==<span class="number">99999</span>)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dfs简单例题"><a href="#dfs简单例题" class="headerlink" title="dfs简单例题"></a>dfs简单例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int R, C;</span><br><span class="line">int map[105][105];</span><br><span class="line">int mark[105][105] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    if (mark[i][j])</span><br><span class="line">        return mark[i][j];//</span><br><span class="line">    if (i != 0 &amp;&amp; map[i - 1][j] &lt; map[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        k = dfs(i - 1, j) + 1;</span><br><span class="line">        if (k &gt; mark[i][j])</span><br><span class="line">            mark[i][j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i != R - 1 &amp;&amp; map[i + 1][j] &lt; map[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        k = dfs(i + 1, j) + 1;</span><br><span class="line">        if (k &gt; mark[i][j])</span><br><span class="line">            mark[i][j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j != 0 &amp;&amp; map[i][j - 1] &lt; map[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        k = dfs(i, j - 1) + 1;</span><br><span class="line">        if (k &gt; mark[i][j])</span><br><span class="line">            mark[i][j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j != C - 1 &amp;&amp; map[i][j + 1] &lt; map[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        k = dfs(i, j + 1) + 1;</span><br><span class="line">        if (k &gt; mark[i][j])</span><br><span class="line">            mark[i][j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    return mark[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k, sum = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;R, &amp;C);</span><br><span class="line">    for (i = 0; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; C; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;map[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; C; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = dfs(i, j);</span><br><span class="line">            if (k &gt; sum)</span><br><span class="line">                sum = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum + 1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典树–前缀树"><a href="#字典树–前缀树" class="headerlink" title="字典树–前缀树"></a>字典树–<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488490&idx=1&sn=db2998cb0e5f08684ee1b6009b974089">前缀树</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=10e5;</span><br><span class="line">static int trie[maxn][26];</span><br><span class="line">static int count1[maxn];</span><br><span class="line">static int index=0;</span><br><span class="line">void insert(string s)//这里是插入数据</span><br><span class="line">&#123;</span><br><span class="line">	int p=0;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">		if(trie[p][u]==0)trie[p][u]=++index;</span><br><span class="line">		p=trie[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	count1[p]++;</span><br><span class="line">&#125;</span><br><span class="line">bool search(string s)//这里是完全搜索数据</span><br><span class="line">&#123;</span><br><span class="line">	int p=0;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">		if(trie[p][u]==0)return false;</span><br><span class="line">		p=trie[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	return count1[p]!=0;</span><br><span class="line">&#125;</span><br><span class="line">bool searchstart(string s)//这里是只搜索前缀是否有共同的</span><br><span class="line">&#123;</span><br><span class="line">	int p=0;</span><br><span class="line">	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">		if(trie[p][u]==0)return false;</span><br><span class="line">		p=trie[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	insert(&quot;aaa&quot;);</span><br><span class="line">	cout&lt;&lt;search(&quot;aa&quot;)&lt;&lt;&quot; &quot;&lt;&lt;search(&quot;aaa&quot;)&lt;&lt;&quot; &quot;&lt;&lt;search(&quot;aaaa&quot;)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;searchstart(&quot;a&quot;)&lt;&lt;&quot; &quot;&lt;&lt;searchstart(&quot;aaa&quot;)&lt;&lt;&quot; &quot;&lt;&lt;searchstart(&quot;aaaa&quot;)&lt;&lt;endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="dfs—1"><a href="#dfs—1" class="headerlink" title="dfs—1"></a>dfs—1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题 C: 【递归入门】组合+判断素数</span><br><span class="line">时间限制: 1 Sec  内存限制: 128 MB</span><br><span class="line">提交: 205  解决: 77</span><br><span class="line">[提交][状态][讨论版][命题人:外部导入]</span><br><span class="line"></span><br><span class="line">题目描述</span><br><span class="line">已知 n 个整数b1,b2,…,bn</span><br><span class="line">以及一个整数 k（k＜n）。</span><br><span class="line">从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。</span><br><span class="line">例如当 n=4，k＝3，4 个整数分别为 3，7，12，19 时，可得全部的组合与它们的和为：</span><br><span class="line">　　　　3＋7＋12=22　　3＋7＋19＝29　　7＋12＋19＝38　　3＋12＋19＝34。</span><br><span class="line">现在，要求你计算出和为素数共有多少种。</span><br><span class="line">例如上例，只有一种的和为素数：3＋7＋19＝29。</span><br><span class="line">输入</span><br><span class="line">第一行两个整数：n , k （1&lt;=n&lt;=20，k＜n） </span><br><span class="line">第二行n个整数：x1,x2，…,xn （1&lt;=xi&lt;=5000000） </span><br><span class="line">输出</span><br><span class="line">一个整数（满足条件的方案数）。 </span><br><span class="line">样例输入</span><br><span class="line">4 3</span><br><span class="line">3 7 12 19</span><br><span class="line">样例输出</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=25;</span><br><span class="line">int a[maxn];</span><br><span class="line">int p[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n,k,ans=0,sum;</span><br><span class="line">bool test(int num)</span><br><span class="line">&#123;</span><br><span class="line">    if(num&lt;=1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i*i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(num%i==0)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if(index==k+1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(test(sum))</span><br><span class="line">        ans++;</span><br><span class="line">        for(int i=1;i&lt;=index-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==false&amp;&amp;i&gt;p[index-1])</span><br><span class="line">        &#123;</span><br><span class="line">            p[index]=i;</span><br><span class="line">            vis[i]=true;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">            dfs(index+1);</span><br><span class="line">            vis[i]=false;</span><br><span class="line">            sum-=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        p[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;); </span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="spfa1–环里有负值"><a href="#spfa1–环里有负值" class="headerlink" title="spfa1–环里有负值"></a>spfa1–环里有负值</h2><p><img src="https://blog-img-mbt321.oss-cn-beijing.aliyuncs.com/img/image-20220411000008537.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5 + 10;</span><br><span class="line">int e[maxn],h[maxn],w[maxn],ne[maxn],idx;</span><br><span class="line">int dist[maxn],st[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">void add(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">int spfa()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof(dist));</span><br><span class="line">    dist[1]=0;</span><br><span class="line">    queue&lt;int&gt;qq;</span><br><span class="line">    qq.push(1);</span><br><span class="line">    st[1]=1;</span><br><span class="line">    while(qq.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t=qq.front();</span><br><span class="line">        qq.pop();</span><br><span class="line">        st[t]=0;</span><br><span class="line">        for(int i=h[t];i!=-1;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j=e[i];</span><br><span class="line">            if(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                if(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    qq.push(j);</span><br><span class="line">                    st[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(dist[n]==0x3f3f3f3f)</span><br><span class="line">    &#123;</span><br><span class="line">        return -0x3f3f3f3f;</span><br><span class="line">    &#125;</span><br><span class="line">    return dist[n];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof(h));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    if(spfa()==-0x3f3f3f3f)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;dist[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="spfa–判断负环"><a href="#spfa–判断负环" class="headerlink" title="spfa–判断负环"></a>spfa–判断负环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5 + 10;</span><br><span class="line">int e[maxn],h[maxn],w[maxn],ne[maxn],idx;</span><br><span class="line">int dist[maxn],st[maxn],cnt[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">void add(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">bool spfa()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;qq;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    qq.push(i);</span><br><span class="line">    st[1]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(qq.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t=qq.front();</span><br><span class="line">        qq.pop();</span><br><span class="line">        st[t]=0;</span><br><span class="line">        for(int i=h[t];i!=-1;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j=e[i];</span><br><span class="line">            if(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+1;</span><br><span class="line">                if(cnt[j]&gt;=n)return true;</span><br><span class="line">                if(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    qq.push(j);</span><br><span class="line">                    st[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof(h));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    if(spfa())&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><h4 id="1-快速幂相对第二种慢一些"><a href="#1-快速幂相对第二种慢一些" class="headerlink" title="1.快速幂相对第二种慢一些"></a>1.快速幂相对第二种慢一些</h4><p><img src="https://blog-img-mbt321.oss-cn-beijing.aliyuncs.com/img/image-20220909135404749.png" alt="image-20220909135404749"></p>
<p>题目链接—<a href="https://www.luogu.com.cn/problem/P3811">https://www.luogu.com.cn/problem/P3811</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll test(ll x,ll y,ll z)</span><br><span class="line">&#123;</span><br><span class="line">    ll sum=1;</span><br><span class="line">    ll ans=x%z;</span><br><span class="line">    while(y)</span><br><span class="line">    &#123;</span><br><span class="line">        if(y&amp;1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=(sum*ans)%z;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*ans)%z;</span><br><span class="line">        y&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    ll n,mod;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;mod;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;test(i,mod-2,mod)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-线性时间复杂度"><a href="#2-线性时间复杂度" class="headerlink" title="2.线性时间复杂度"></a>2.线性时间复杂度</h4><p>这里主要是最好用<cstdio>节省时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long inv[3000010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long  n,mod;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;mod);</span><br><span class="line">    printf(&quot;1\n&quot;);</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i]=mod-(mod/i)*inv[mod%i]%mod;</span><br><span class="line">        printf(&quot;%lld\n&quot;,inv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h4 id="1-最简单的-题目在下面"><a href="#1-最简单的-题目在下面" class="headerlink" title="1.最简单的 题目在下面"></a>1.最简单的 题目在下面</h4><p><a href="https://img-blog.csdnimg.cn/2020021217471941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2020021217471941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6;</span><br><span class="line">ll arr[maxn];</span><br><span class="line">struct st</span><br><span class="line">&#123;</span><br><span class="line">    ll l;</span><br><span class="line">    ll r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125; tree[maxn];</span><br><span class="line">void build(int i, int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    tree[i].l = l;</span><br><span class="line">    tree[i].r = r;</span><br><span class="line">    if (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].sum = arr[l];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; 1;</span><br><span class="line">    build(i * 2, l, mid);</span><br><span class="line">    build(i * 2 + 1, mid + 1, r);</span><br><span class="line">    tree[i].sum = tree[i * 2].sum * tree[i * 2 + 1].sum;</span><br><span class="line">&#125;</span><br><span class="line">ll search(ll i, ll l, ll r)</span><br><span class="line">&#123;</span><br><span class="line">    if (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">        return tree[i].sum;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    if (tree[i * 2].r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (res * search(i * 2, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree[i * 2 + 1].l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (res * search(i * 2 + 1, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    build(1, 1, n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n - k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans, search(1, i, i + k - 1));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-简单的模板-随意加和查询"><a href="#2-简单的模板-随意加和查询" class="headerlink" title="2.简单的模板 随意加和查询"></a>2.简单的模板 随意加和查询</h4><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 10e6;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll arr[maxn];</span><br><span class="line"></span><br><span class="line">struct st</span><br><span class="line">&#123;</span><br><span class="line">    ll l, r, sum, lz;</span><br><span class="line">&#125; tree[maxn];</span><br><span class="line"></span><br><span class="line">void build(ll i, ll l, ll r, ll *arr)</span><br><span class="line">&#123;</span><br><span class="line">    tree[i].l = l;</span><br><span class="line">    tree[i].r = r;</span><br><span class="line">    tree[i].lz = 0;</span><br><span class="line">    if (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].sum = arr[l];</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; 1;</span><br><span class="line">    build(i * 2, l, mid, arr);</span><br><span class="line">    build(i * 2 + 1, mid + 1, r, arr);</span><br><span class="line">    tree[i].sum = tree[i * 2].sum + tree[i * 2 + 1].sum;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 主要作用是不让往下遍历（标记），直接存这里就好，之后（搜索查找的时候再传下去）或者再次添加的时候传下去，保证结果正确 --&gt;</span><br><span class="line">void push_down(ll i)</span><br><span class="line">&#123;</span><br><span class="line">    if (tree[i].lz != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i * 2].lz += tree[i].lz;</span><br><span class="line">        tree[i * 2 + 1].lz += tree[i].lz;</span><br><span class="line">        int mid = (tree[i].l + tree[i].r) / 2;</span><br><span class="line">        tree[i * 2].sum += tree[i].lz * (mid - tree[i * 2].l + 1);</span><br><span class="line">        tree[i * 2 + 1].sum += tree[i].lz * (tree[i * 2+1].r - mid);</span><br><span class="line">        tree[i].lz = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(ll i, ll l, ll r, ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].sum += k * (tree[i].r - tree[i].l + 1);</span><br><span class="line">        tree[i].lz += k;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(i);</span><br><span class="line">    if (tree[i * 2].r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i * 2, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree[i * 2 + 1].l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i * 2 + 1, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tree[i].sum = tree[i * 2].sum + tree[i * 2 + 1].sum;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll searchs(ll i, ll l, ll r)</span><br><span class="line">&#123;</span><br><span class="line">    if (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        return tree[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(i);</span><br><span class="line">    ll num = 0;</span><br><span class="line">    if (tree[i * 2].r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        num += searchs(i * 2, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tree[i * 2 + 1].l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        num += searchs(i * 2 + 1, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0), cout.tie(0);</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    build(1, 1, n, arr);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        if (temp == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ll a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            add(1, a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ll a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            cout &lt;&lt; searchs(1, a, b)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://blog.csdn.net/qq_43619271/article/details/109091314?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165121095416782184637180%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165121095416782184637180&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-109091314.nonecase&utm_term=%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&spm=1018.2226.3001.4450">https://blog.csdn.net/qq_43619271/article/details/109091314?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165121095416782184637180%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165121095416782184637180&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-109091314.nonecase&amp;utm_term=%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&amp;spm=1018.2226.3001.4450</a></p>
<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 505;</span><br><span class="line">int INF = 0x3f3f3f3f;</span><br><span class="line">int edge[maxn][maxn];</span><br><span class="line">int dist[maxn], vis[maxn];</span><br><span class="line">int n, m, u, v, w;</span><br><span class="line">long long sum = 0;</span><br><span class="line">long long prime(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    dist[pos] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur = -1;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; (cur == -1 || dist[j] &lt; dist[cur]))</span><br><span class="line">            &#123;</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dist[cur] &gt;= INF)</span><br><span class="line">            return INF;</span><br><span class="line">        sum += dist[cur];</span><br><span class="line">        vis[cur] = 1;</span><br><span class="line">        for (int k = 1; k &lt;= n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[k])</span><br><span class="line">                dist[k] = min(dist[k], edge[cur][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    memset(dist, 0x3f, sizeof(dist));</span><br><span class="line">    memset(edge, 0x3f, sizeof(edge));</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edge[u][v] = min(edge[u][v],w);</span><br><span class="line">        edge[v][u] = min(edge[v][u],w);</span><br><span class="line">    &#125;</span><br><span class="line">    long long value = prime(1);</span><br><span class="line">    if (value &gt;= INF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal算法求最小生成树"><a href="#Kruskal算法求最小生成树" class="headerlink" title="Kruskal算法求最小生成树"></a>Kruskal算法求最小生成树</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 10e6;</span><br><span class="line">struct st</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int z;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line">int  fa[maxn];</span><br><span class="line">long long sum=0;</span><br><span class="line">int find1(int key)</span><br><span class="line">&#123;</span><br><span class="line">    if (fa[key] == key)</span><br><span class="line">    &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return fa[key] = find1(fa[key]);</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(st s1, st s2)</span><br><span class="line">&#123;</span><br><span class="line">    return s1.z &lt; s2.z;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge+1, edge + m+1, cmp);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x = find1(edge[i].x);</span><br><span class="line">        int y = find1(edge[i].y);</span><br><span class="line">        if (x == y)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        sum += edge[i].z;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i == fa[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans &gt; 1)</span><br><span class="line">        cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; sum;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><h4 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6;</span><br><span class="line">int h[N], e[N], ne[N], idx;</span><br><span class="line">int color[N];</span><br><span class="line">void add(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    ne[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int i, int k)</span><br><span class="line">&#123;</span><br><span class="line">    color[i] = k;</span><br><span class="line">    for (int j = h[i]; j != -1; j = ne[j])</span><br><span class="line">    &#123;</span><br><span class="line">        int b = e[j];</span><br><span class="line">        if (!color[b])</span><br><span class="line">        &#123;</span><br><span class="line">            if (!dfs(b, 3 - k))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (color[b] &amp;&amp; color[b] != 3 - k)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    memset(h, -1, sizeof(h));</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    int u, v;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (!dfs(i, 1))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="辛普森积分"><a href="#辛普森积分" class="headerlink" title="辛普森积分"></a>辛普森积分</h4><p><a href="https://blog.csdn.net/weixin_30444105/article/details/95306900?ops_request_misc=%7B%22request_id%22:%22165132001016782390558168%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165132001016782390558168&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-95306900.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_30444105&#x2F;article&#x2F;details&#x2F;95306900?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522165132001016782390558168%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;165132001016782390558168&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduend~default-1-95306900.142^v9^pc_search_result_control_group,157^v4^control&amp;utm_term&#x3D;辛普森积分&amp;spm&#x3D;1018.2226.3001.4187</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b, c, d, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">f</span><span class="params">(db x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (c * x + d) / (a * x + b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">sim</span><span class="params">(db l, db r)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">f</span>(l)+<span class="built_in">f</span>(r)+<span class="number">4</span>*<span class="built_in">f</span>((l+r)/<span class="number">2</span>))*(r-l)/<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asr</span><span class="params">(db L, db R,db esp ,db val)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  db mid=(L+R)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  db lval=<span class="built_in">sim</span>(L,mid);</span><br><span class="line"></span><br><span class="line">  db rval=<span class="built_in">sim</span>(mid,R);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fabs</span>(lval+rval-val)&lt;=<span class="number">15</span>*esp)&#123;<span class="keyword">return</span> lval+rval+(lval+rval-val)/<span class="number">15</span>;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">asr</span>(L,mid,esp/<span class="number">2</span>,lval)+<span class="built_in">asr</span>(mid,R,esp/<span class="number">2</span>,rval);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asme</span><span class="params">(db L, db R, db esp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">asr</span>(L, R, esp, <span class="built_in">sim</span>(L, R));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; L &gt;&gt; R;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt; <span class="built_in">asme</span>(L, R, esp);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h4 id="面积公式"><a href="#面积公式" class="headerlink" title="*面积公式*"></a><em><strong>*面积公式*</strong></em></h4><p>double area(BWE A,BWE B,BWE C)</p>
<p>{</p>
<p>  &#x2F;&#x2F;用于计算三角形面积的函数(直接套用题目中的公式) </p>
<p>​	return abs(A.x*(B.y-C.y)+B.x*(C.y-A.y)+C.x*(A.y-B.y))&#x2F;2;</p>
<p>}</p>
<h4 id="求两点之间的整数点个数"><a href="#求两点之间的整数点个数" class="headerlink" title="求两点之间的整数点个数"></a>求两点之间的整数点个数</h4><p>gcd(abs(a1-a2), abs(b1-b2));</p>
<h4 id="皮克定理"><a href="#皮克定理" class="headerlink" title="皮克定理"></a>皮克定理</h4><p>其中a表示多边形内部的点数（就是题目中要求的答案)，b表示多边形恰好落在边界上的点数，s表示多边形的面积。 易知，a&#x3D;S-b&#x2F;2+1</p>
<h4 id="旋转点"><a href="#旋转点" class="headerlink" title="旋转点"></a>旋转点</h4><p>我们可以这样认为：对于任意点A(x,y)，A非原点，绕原点旋转θ角后点的坐标为： (xcosθ- y * sinθ, ycosθ + x * sinθ)、 如果不绕原点的话可以直接加减(xx,yy); (xcosθ- y * sinθ+xx, ycosθ + x * sinθ+yy)、 绕其他(x2,y2)点旋转 ((x-x2)*cosθ- (y-y2) * sinθ+x2, (y-y2)*cosθ + (x-x2) * sinθ+y2)</p>
<h4 id="求凸包模板题"><a href="#求凸包模板题" class="headerlink" title="求凸包模板题"></a>求凸包模板题</h4><p><a href="https://www.luogu.com.cn/problem/P2742">https://www.luogu.com.cn/problem/P2742</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ben</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">&#125; p[<span class="number">100005</span>], s[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">check</span><span class="params">(ben a1, ben a2, ben b1, ben b2)</span> <span class="comment">//检查叉积是否大于0，如果是a就逆时针转到b</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d</span><span class="params">(ben p1, ben p2)</span> <span class="comment">//两点间距离。。。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ben lhs, ben rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">d</span>(p[<span class="number">1</span>], lhs) &lt; <span class="built_in">d</span>(p[<span class="number">1</span>], rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">double</span> ll, <span class="type">double</span> ff)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> mid;</span><br><span class="line"></span><br><span class="line">    p[num].x = ll, p[num].y = ff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p[num].y &lt; p[<span class="number">1</span>].y || (p[num].y == p[<span class="number">1</span>].y &amp;&amp; p[num].x &lt; p[<span class="number">1</span>].x))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(p[num], p[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  freopen(&quot;b.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> mid, ll, ff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;ll, &amp;ff);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(ll, ff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">2</span>, p + <span class="number">1</span> + n, cmp); <span class="comment">//系统快排</span></span><br><span class="line"></span><br><span class="line">    s[<span class="number">1</span>] = p[<span class="number">1</span>]; <span class="comment">//最低点一定在凸包里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(s[cnt - <span class="number">1</span>], s[cnt], s[cnt], p[i]) &lt; <span class="number">0</span>) <span class="comment">//判断前面的会不会被踢走，如果被踢走那么出栈</span></span><br><span class="line"></span><br><span class="line">            cnt--;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        s[cnt] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[cnt + <span class="number">1</span>] = p[<span class="number">1</span>]; <span class="comment">//最后一个点回到凸包起点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line"></span><br><span class="line">        ans += <span class="built_in">d</span>(s[i], s[i + <span class="number">1</span>]); <span class="comment">//然后s里存好了凸包序列，只需要把两两距离累加就行</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="求凸包-难一点"><a href="#求凸包-难一点" class="headerlink" title="求凸包 难一点"></a>求凸包 难一点</h4><p><a href="https://www.luogu.com.cn/problem/P3829">https://www.luogu.com.cn/problem/P3829</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-12</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a, b, r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ben</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">&#125; p[<span class="number">1000005</span>], s[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">check</span><span class="params">(ben a1, ben a2, ben b1, ben b2)</span> <span class="comment">//检查叉积是否大于0(小于180度)，等于零(平行)，如果是a就逆时针转到b</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d</span><span class="params">(ben p1, ben p2)</span> <span class="comment">//两点间距离。。。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span> <span class="params">(ben lhs, ben rhs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check</span> (p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check</span> (p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">d</span> (p[<span class="number">1</span>], lhs) &lt; <span class="built_in">d</span> (p[<span class="number">1</span>], rhs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">double</span> ll, <span class="type">double</span> ff)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> mid;</span><br><span class="line"></span><br><span class="line">  p[num].x = ll, p[num].y = ff;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p[num].y &lt; p[<span class="number">1</span>].y || (p[num].y == p[<span class="number">1</span>].y &amp;&amp; p[num].x &lt; p[<span class="number">1</span>].x)) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">swap</span> (p[num], p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  num++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;b.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf%lf&quot;</span>, &amp;n, &amp;b, &amp;a, &amp;r);</span><br><span class="line"></span><br><span class="line">  a = a / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">  b = b / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> mid, xx, yx, th;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;xx, &amp;yx, &amp;th);</span><br><span class="line"></span><br><span class="line">   xx += eps;</span><br><span class="line"></span><br><span class="line">   yx += eps;</span><br><span class="line"></span><br><span class="line">   th += eps;</span><br><span class="line"></span><br><span class="line">   <span class="type">double</span> s1 = <span class="built_in">sin</span>(th);</span><br><span class="line"></span><br><span class="line">   <span class="type">double</span> c1 = <span class="built_in">cos</span>(th);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">add</span>((a - r) * c1 - (b - r) * s1 + xx, (b - r) * c1 + (a - r) * s1 + yx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// cout&lt;&lt;(a-r)*c1-(b-r)*s1+xx&lt;&lt;&quot; &quot; &lt;&lt;(b-r)*c1+(a-r)*s1+yx&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">add</span>(-(a - r) * c1 - (b - r) * s1 + xx, (b - r) * c1 - (a - r) * s1 + yx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// cout&lt;&lt;-(a-r)*c1-(b-r)*s1+xx&lt;&lt;&quot; &quot;&lt;&lt;(b-r)*c1-(a-r)*s1+yx&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">add</span>((a - r) * c1 + (b - r) * s1 + xx, -(b - r) * c1 + (a - r) * s1 + yx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// cout&lt;&lt;(a-r)*c1+(b-r)*s1+xx&lt;&lt;&quot; &quot;&lt;&lt; -(b-r)*c1+(a-r)*s1+yx&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">add</span>(-(a - r) * c1 + (b - r) * s1 + xx, -(b - r) * c1 - (a - r) * s1 + yx);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// cout&lt;&lt;-(a-r)*c1+(b-r)*s1+xx&lt;&lt;&quot; &quot;&lt;&lt;-(b-r)*c1-(a-r)*s1+yx&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cout&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(p + <span class="number">2</span>, p + num, cmp); <span class="comment">//系统快排</span></span><br><span class="line"></span><br><span class="line">  s[<span class="number">1</span>] = p[<span class="number">1</span>];        <span class="comment">//最低点一定在凸包里</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(s[cnt - <span class="number">1</span>], s[cnt], s[cnt], p[i]) &lt;= <span class="number">0</span>) <span class="comment">//判断前面的会不会被踢走，如果被踢走那么出栈</span></span><br><span class="line"></span><br><span class="line">     cnt--;</span><br><span class="line"></span><br><span class="line">   cnt++;</span><br><span class="line"></span><br><span class="line">   s[cnt] = p[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s[cnt + <span class="number">1</span>] = p[<span class="number">1</span>]; <span class="comment">//最后一个点回到凸包起点</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line"></span><br><span class="line">   ans += <span class="built_in">d</span>(s[i], s[i + <span class="number">1</span>]); <span class="comment">//然后s里存好了凸包序列，只需要把两两距离累加就行</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans + <span class="number">3.141592653589793</span> * <span class="number">2</span> * r);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h4><p><a href="https://www.luogu.com.cn/problem/P1452">https://www.luogu.com.cn/problem/P1452</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ben</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">&#125; p[<span class="number">100005</span>], s[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">check</span><span class="params">(ben u1, ben u2, ben v1, ben v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (u2.x - u1.x) * (v2.y - v1.y) - (u2.y - u1.y) * (v2.x - v1.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d</span><span class="params">(ben p1, ben p2)</span> <span class="comment">//两点间距离。。。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ben lhs, ben rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(p[<span class="number">1</span>], lhs, p[<span class="number">1</span>], rhs) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">d</span>(p[<span class="number">1</span>], lhs) &lt; <span class="built_in">d</span>(p[<span class="number">1</span>], rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">double</span> ll, <span class="type">double</span> ff)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> mid;</span><br><span class="line"></span><br><span class="line">    p[num].x = ll, p[num].y = ff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p[num].y &lt; p[<span class="number">1</span>].y || (p[num].y == p[<span class="number">1</span>].y &amp;&amp; p[num].x &lt; p[<span class="number">1</span>].x))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(p[num], p[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> mid, ll, ff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;ll, &amp;ff);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(ll, ff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">2</span>, p + num, cmp); <span class="comment">//系统快排</span></span><br><span class="line"></span><br><span class="line">    s[<span class="number">1</span>] = p[<span class="number">1</span>]; <span class="comment">//最低点一定在凸包里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(s[cnt - <span class="number">1</span>], s[cnt], s[cnt], p[i]) &lt;= <span class="number">0</span>) <span class="comment">//判断前面的会不会被踢走，如果被踢走那么出栈</span></span><br><span class="line"></span><br><span class="line">            cnt--;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        s[cnt] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[cnt + <span class="number">1</span>] = p[<span class="number">1</span>]; <span class="comment">//最后一个点回到凸包起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">d</span>(s[<span class="number">1</span>], s[<span class="number">2</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= cnt; ++u)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">check</span>(s[u], s[u + <span class="number">1</span>], s[u + <span class="number">1</span>], s[v]) &lt;=</span><br><span class="line"></span><br><span class="line">               <span class="built_in">check</span>(s[u], s[u + <span class="number">1</span>], s[u + <span class="number">1</span>], s[v + <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            v = v == cnt ? <span class="number">1</span> : v + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">d</span>(s[u], s[v]), <span class="built_in">d</span>(s[u + <span class="number">1</span>], s[v])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= cnt; i++)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   ans += d(s[i], s[i + 1]); //然后s里存好了凸包序列，只需要把两两距离累加就行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><p>****推荐学习网址****：<a href="https://www.cnblogs.com/-citywall123/p/11688576.html%EF%BC%9B">https://www.cnblogs.com/-citywall123/p/11688576.html；</a></p>
<p>****注意****：</p>
<p><em><strong>*在有符号整型和无符号整型的比较中，自动将有符号整型数转换为无符号整型。*</strong></em></p>
<p>C++方法：</p>
<p>不要尝试理解kmp算法，与递归同理</p>
<p>下面是求****Next****数组的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1008</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Next[n];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= s.<span class="built_in">length</span>())</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == s[j])</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Next[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            j = Next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">aa</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>****下面是全的代码****：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> next1[n];</span><br><span class="line"></span><br><span class="line">string re;</span><br><span class="line"></span><br><span class="line">string te;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> re1, te1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    next1[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	**i在前面，j在后面**</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; te1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || te[i] == te[j])</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            next1[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            j = next1[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_piace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; re1 &amp;&amp; j &lt; te1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || te[j] == re[i])</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            j = next1[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt;= te1)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i - te1 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; re &gt;&gt; te;</span><br><span class="line"></span><br><span class="line">    re1 = re.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    te1 = te.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_ne</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找到的位置初始是：&quot;</span> &lt;&lt; <span class="built_in">get_piace</span>() &lt;&lt; endl <span class="comment">//由一开始的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列 LIS"></a>最长上升子序列 LIS</h2><h4 id="1-dp-最长联通串"><a href="#1-dp-最长联通串" class="headerlink" title="1.dp  最长联通串"></a>1.dp  最长联通串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> va[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b[num]) <span class="built_in">dfs</span>(b[num]);</span><br><span class="line">	cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;b.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> temp;</span><br><span class="line">			cin&gt;&gt;temp;</span><br><span class="line">			<span class="keyword">if</span>(temp)</span><br><span class="line">			&#123;</span><br><span class="line">				va[i][j]=<span class="number">1</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(va[j][i]&amp;&amp;dp[i]&lt;dp[j]+a[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i]=dp[j]+a[i];</span><br><span class="line">				b[i]=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans&lt;dp[i])</span><br><span class="line">		&#123;</span><br><span class="line">			ans=dp[i];</span><br><span class="line">			pos=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(pos);</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;ans;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-二分实现时间更短"><a href="#2-二分实现时间更短" class="headerlink" title="2.二分实现时间更短"></a>2.二分实现时间更短</h4> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn], f[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = cnt; </span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    f[++cnt] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) </span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; f[cnt]) f[ ++ cnt] = a[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">find</span>(a[i]);</span><br><span class="line">            f[tmp] = a[i]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCS最长公共子序列"><a href="#LCS最长公共子序列" class="headerlink" title="LCS最长公共子序列"></a>LCS最长公共子序列</h2><p>相当于用数组映射让第一个数组单调递增，之后数组映射获得在此情况下的另一个数组，最后要求的结果就变成了lis</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N],mp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;b.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		mp[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;b[i];</span><br><span class="line">		f[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[b[i]]&gt;f[len])</span><br><span class="line">		&#123;</span><br><span class="line">			f[++len]=mp[b[i]];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			*<span class="built_in">lower_bound</span>(f,f+len,mp[b[i]])=mp[b[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Sh脚本实现数据库备份</title>
    <url>/2024/02/20/Sh%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="Sh脚本实现数据库备份"><a href="#Sh脚本实现数据库备份" class="headerlink" title="Sh脚本实现数据库备份"></a>Sh脚本实现数据库备份</h2><p>backup.sh：备份个人库、团队库，备份建表语句到hdfs上一个文件夹<br>restore.sh：恢复个人库、团队库，备份建表语句<br>delbak.sh：crontab配置，删除hdfs上超过两周的文件夹</p>
<h4 id="backup-sh"><a href="#backup-sh" class="headerlink" title="backup.sh"></a>backup.sh</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">BACKUP_ROOT=/root/cicc/</span><br><span class="line">BACKUP_DATE=$(date +%Y%m%d)</span><br><span class="line">BACKUP_LOG=$&#123;BACKUP_ROOT&#125;/log/$(basename $0).$&#123;BACKUP_DATE&#125;.log</span><br><span class="line"></span><br><span class="line">backup_beeline() &#123;</span><br><span class="line">    beeline -u &quot;jdbc:hive2://tq-dev-node2:10000/;guardianToken=wOAseBo1stuRYlvjtZDR-TDH&quot; --color=false --showHeader=false --showWarnings=false --silent=true --outputformat=csv --maxWidth=1000 -n admin -p admin -e &quot;$1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backup_timelyre_database() &#123;</span><br><span class="line">    echo &quot;$(date +%c): backup timelyre database $1 starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">    ORIGIN_DATABASE=$1;</span><br><span class="line">    BACKUP_DATABASE=$1_backup_$BACKUP_DATE;</span><br><span class="line"></span><br><span class="line">    BACKUP_PATH=$&#123;BACKUP_ROOT&#125;/dat/$&#123;BACKUP_DATE&#125;</span><br><span class="line">    if [ ! -d $&#123;BACKUP_PATH&#125; ]; then</span><br><span class="line">        mkdir -p $&#123;BACKUP_PATH&#125;;</span><br><span class="line">    fi</span><br><span class="line">    mkdir -p $BACKUP_PATH/$ORIGIN_DATABASE;</span><br><span class="line"></span><br><span class="line">    backup_beeline &quot;create database if not exists $BACKUP_DATABASE;&quot;</span><br><span class="line"></span><br><span class="line">    BACKUP_TABLES=$(backup_beeline &quot;use $1; show tables;&quot;|xargs)</span><br><span class="line">    for TABLE in $BACKUP_TABLES</span><br><span class="line">    do</span><br><span class="line">        backup_beeline &quot;show create table $ORIGIN_DATABASE.$TABLE;&quot;|xargs &gt; $BACKUP_PATH/$ORIGIN_DATABASE/$TABLE.sql</span><br><span class="line">        backup_beeline &quot;create table if not exists $BACKUP_DATABASE.$TABLE stored as CSVFILE as select * from $ORIGIN_DATABASE.$TABLE&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$(date +%c): backup timelyre database $1 finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backup_timelyre() &#123;</span><br><span class="line">    echo &quot;$(date +%c): backup timelyre starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">    BACKUP_DATABASES=$(backup_beeline &quot;show databases;&quot;|xargs)</span><br><span class="line">    for DATABASE in $BACKUP_DATABASES</span><br><span class="line">    do</span><br><span class="line">        echo &quot;process database $DATABASE&quot;</span><br><span class="line">	if [[ &quot;$DATABASE&quot; == *&quot;_private&quot; || &quot;$DATABASE&quot; == *&quot;_public&quot; || &quot;$DATABASE&quot; == *&quot;_meta&quot; ]]; then</span><br><span class="line">	    backup_timelyre_database $DATABASE</span><br><span class="line">	fi</span><br><span class="line">    done</span><br><span class="line">    echo &quot;$(date +%c): backup timelyre finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># main</span><br><span class="line">echo &quot;$(date +%c) backup $&#123;BACKUP_PATH&#125; starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">source /var/lib/transwarp-manager/master/content/resources/tdh_client/init.sh;</span><br><span class="line"></span><br><span class="line">#backup_timelyre</span><br><span class="line"></span><br><span class="line">backup_timelyre_database &quot;user3_private&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;$(date +%c) backup $&#123;BACKUP_PATH&#125; finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">exit 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="restore-sh"><a href="#restore-sh" class="headerlink" title="restore.sh"></a>restore.sh</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">estore#!/bin/bash</span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Input Argument Error!&quot;</span><br><span class="line">    echo &quot;Usage: $0 [BACKUP_DATE]&quot;</span><br><span class="line">    exit 1;</span><br><span class="line">fi</span><br><span class="line">RESTORE_DATE=$1</span><br><span class="line"></span><br><span class="line">BACKUP_ROOT=/root/cicc</span><br><span class="line">BACKUP_DATE=$(date +%Y%m%d)</span><br><span class="line">BACKUP_LOG=$&#123;BACKUP_ROOT&#125;/log/$(basename $0).$&#123;BACKUP_DATE&#125;.log</span><br><span class="line"></span><br><span class="line">restore_beeline() &#123;</span><br><span class="line">    beeline -u &quot;jdbc:hive2://tq-dev-node2:10000/;guardianToken=wOAseBo1stuRYlvjtZDR-TDH&quot; --color=false --showHeader=false --showWarnings=false --silent=true --outputformat=csv --maxWidth=1000 -n admin -p admin -e &quot;$1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">restore_timelyre_database() &#123;</span><br><span class="line">    echo &quot;$(date +%c): restore timelyre database $1 with $2 starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">    ORIGIN_DATABASE=$1;</span><br><span class="line">    BACKUP_DATABASE=$1_backup_$RESTORE_DATE;</span><br><span class="line">    RESTORE_PATH=$2;</span><br><span class="line"></span><br><span class="line">    for file in $(find $RESTORE_PATH/$&#123;DATABASE&#125;/* -maxdepth 0 -type f); do</span><br><span class="line">	TABLE=$(basename &quot;$&#123;file%.sql&#125;&quot;)</span><br><span class="line">	echo &quot;restore table $ORIGIN_DATABASE.$TABLE with $BACKUP_DATABASE.$TABLE and schema $file&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">        #restore_beeline &quot;drop table $ORIGIN_DATABASE.$TABLE;&quot;</span><br><span class="line">	#restore_beeline &quot;$(cat $file)&quot;</span><br><span class="line">        #restore_beeline &quot;insert into $ORIGIN_DATABASE.$TABLE select * from $BACKUP_DATABASE.$TABLE;&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$(date +%c): restore timelyre database $1 with $2 finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">restore_timelyre() &#123;</span><br><span class="line">    echo &quot;$(date +%c): restore timelyre starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">    RESTORE_PATH=$BACKUP_ROOT/dat/$RESTORE_DATE;</span><br><span class="line">    if [ ! -d $RESTORE_PATH ]; then</span><br><span class="line">        echo &quot;backup $RESTORE_PATH not exists&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">        exit -1;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    for db in $(find $RESTORE_PATH/* -maxdepth 0 -type d); do</span><br><span class="line">        DATABASE=$(basename $db)</span><br><span class="line">        echo &quot;restore database: $&#123;DATABASE&#125; with $&#123;RESTORE_PATH&#125;&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">	restore_timelyre_database $DATABASE $RESTORE_PATH</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$(date +%c): restore timelyre finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># main</span><br><span class="line">echo &quot;$(date +%c) restore $&#123;RESTORE_DATE&#125; starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /var/lib/transwarp-manager/master/content/resources/tdh_client/init.sh;</span><br><span class="line"></span><br><span class="line">restore_timelyre</span><br><span class="line"></span><br><span class="line">echo &quot;$(date +%c) restore $&#123;RESTORE_DATE&#125; finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">exit 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="delbak-sh"><a href="#delbak-sh" class="headerlink" title="delbak.sh"></a>delbak.sh</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">BACKUP_ROOT=/root/cicc</span><br><span class="line">BACKUP_DATE=$(date +%Y%m%d)</span><br><span class="line">BACKUP_LOG=$&#123;BACKUP_ROOT&#125;/log/$(basename $0).$&#123;BACKUP_DATE&#125;.log</span><br><span class="line"></span><br><span class="line"># this should be +14, means more than 14 days ago</span><br><span class="line">MTIME=-1</span><br><span class="line"></span><br><span class="line">backup_beeline() &#123;</span><br><span class="line">    beeline -u &quot;jdbc:hive2://tq-dev-node2:10000/;guardianToken=wOAseBo1stuRYlvjtZDR-TDH&quot; --color=false --showHeader=false --showWarnings=false --silent=true --outputformat=csv --maxWidth=1000 -n admin -p admin -e &quot;$1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clean_old_backups() &#123;</span><br><span class="line">    echo &quot;$(date +%c): clean old backups starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">    for dir in $(find $&#123;BACKUP_ROOT&#125;/dat/* -maxdepth 0 -mtime $MTIME -type d); do</span><br><span class="line">	echo &quot;delete backup dir: $dir&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">	DELETE_DATE=$(basename $dir)</span><br><span class="line">        for db in $(find $dir/* -maxdepth 0 -type d); do</span><br><span class="line">	    DATABASE=$(basename $db)</span><br><span class="line">	    echo &quot;drop backup database: $&#123;DATABASE&#125;_backup_$&#123;DELETE_DATE&#125;&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">            #backup_beeline &quot;drop database if exists $DATABASE_backup_$DELETE_DATE;&quot;</span><br><span class="line">	done</span><br><span class="line">	#rm -fr $dir</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo &quot;$(date +%c): clean old backups finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># main</span><br><span class="line">echo &quot;$(date +%c) delbak starting...&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line">clean_old_backups</span><br><span class="line">echo &quot;$(date +%c) delbak finished!!!&quot;|tee -a $&#123;BACKUP_LOG&#125;</span><br><span class="line"></span><br><span class="line">exit 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>笔记</category>
        <category>sh</category>
      </categories>
      <tags>
        <tag>sh</tag>
      </tags>
  </entry>
  <entry>
    <title>TEST</title>
    <url>/2024/02/02/TEST/</url>
    <content><![CDATA[<p><img src="https://blog-img-mbt321.oss-cn-beijing.aliyuncs.com/img/wallhaven-9depzk.jpg" alt="wallhaven-9depzk"></p>
<details class="toggle" ><summary class="toggle-button" style="">点击以打开</summary><div class="toggle-content"><p>折叠栏目</p>
</div></details>

<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>这里是代码</p></div><div class="tab-item-content" id="样例-2"><p>这里是预览</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
]]></content>
      <categories>
        <category>A</category>
        <category>B</category>
      </categories>
      <tags>
        <tag>TEST</tag>
      </tags>
  </entry>
  <entry>
    <title>MYDB项目详解</title>
    <url>/2024/06/24/MYDB%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a>MYDB</h2><p>MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>五个模块的依赖关系如下：</p>
<p><img src="https://shinya.click/images/mydb0.jpg" alt="img"></p>
<p>MYDB 模块依赖</p>
<p>从这个依赖图中，拓扑排序一下就能看出实现顺序。本教程的实现顺序是 TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p>
<p>每个模块的职责如下：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h2 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h2><p>让我们通过一个假想的例子来详解一个 <code>XID</code> 文件的结构和如何利用它来记录事务的状态。假设我们的系统已经处理了几个事务，并且事务的 <code>XID</code> 分别是从 1 到 5。我们将看到如何在 <code>XID</code> 文件中记录这些事务的状态。</p>
<h3 id="XID-文件结构"><a href="#XID-文件结构" class="headerlink" title="XID 文件结构"></a>XID 文件结构</h3><ul>
<li>文件的第一部分是一个8字节的数字，表示当前文件所记录的事务总数。</li>
<li>接下来的部分是每个事务的状态，每个状态占用1字节空间。</li>
</ul>
<h3 id="事务状态编码"><a href="#事务状态编码" class="headerlink" title="事务状态编码"></a>事务状态编码</h3><p>假设我们用以下编码表示不同的事务状态：</p>
<ul>
<li><code>0x00</code> - active (活动)</li>
<li><code>0x01</code> - committed (已提交)</li>
<li><code>0x02</code> - aborted (已撤销)</li>
</ul>
<h3 id="假设的-XID-文件内容"><a href="#假设的-XID-文件内容" class="headerlink" title="假设的 XID 文件内容"></a>假设的 XID 文件内容</h3><p>假设我们的系统中有5个事务的状态如下：</p>
<ul>
<li><code>XID 1</code> - committed</li>
<li><code>XID 2</code> - aborted</li>
<li><code>XID 3</code> - committed</li>
<li><code>XID 4</code> - active</li>
<li><code>XID 5</code> - committed</li>
</ul>
<h3 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h3><p>文件的具体布局将如下所示（数字表示事务的状态编码，每个数字代表1字节）：</p>
<ul>
<li>头部（8字节）: 存储数字 5 (因为有5个事务)</li>
<li>事务1的状态（1字节）: 0x01 (committed)</li>
<li>事务2的状态（1字节）: 0x02 (aborted)</li>
<li>事务3的状态（1字节）: 0x01 (committed)</li>
<li>事务4的状态（1字节）: 0x00 (active)</li>
<li>事务5的状态（1字节）: 0x01 (committed)</li>
</ul>
<h3 id="文件示例的字节表达："><a href="#文件示例的字节表达：" class="headerlink" title="文件示例的字节表达："></a>文件示例的字节表达：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css</span><br><span class="line">Copy code</span><br><span class="line">[00 00 00 00 00 00 00 05][01][02][01][00][01]</span><br></pre></td></tr></table></figure>

<p>这里：</p>
<ul>
<li><code>[00 00 00 00 00 00 00 05]</code> 是文件头部的8字节，表示管理的事务总数为5。</li>
<li>后续的每个 <code>[XX]</code> 表示一个事务的状态，从 <code>XID 1</code> 到 <code>XID 5</code>。</li>
</ul>
<p>通过这样的布局，<code>TransactionManager</code> 可以轻松定位任何事务的状态信息。例如，如果想知道 <code>XID 4</code> 的状态，可以直接跳到文件的第12字节位置（头部8字节 + 前三个事务各占1字节 + 1字节偏移量因为事务ID从1开始）。这种方法提供了快速访问和更新事务状态的能力，非常适合需要高效事务处理的数据库系统。</p>
<h3 id="TM问题"><a href="#TM问题" class="headerlink" title="TM问题"></a>TM问题</h3><p>1.如何保证文件不发生问题<br>通过检查前8个字节查看事务的数量 之后计算总的字节数与文件的总字节数比较，来保证问题</p>
<p>2.为啥是xid-1呢</p>
<p>因为数组或者内存都是索引都是从0开始，计算的时候要这样取</p>
<p>3.为什么需要xid</p>
<ul>
<li><strong>唯一标识</strong>：每个事务有一个唯一的 <code>XID</code>，这允许系统精确地追踪和控制每个独立的操作。</li>
<li><strong>状态管理</strong>：通过 <code>XID</code>，系统能够管理每个事务的状态（活动、已提交、已撤销）。这对于处理并发操作和系统故障恢复至关重要。</li>
<li><strong>错误恢复</strong>：在系统或硬件故障时，<code>XID</code> 和事务状态可以帮助系统决定哪些事务需要重新执行（例如，所有未提交的事务）。</li>
</ul>
<p>4.事务状态有哪些</p>
<ul>
<li>每个事务有三种可能的状态：<ul>
<li><code>active</code>：事务正在进行中，尚未结束。</li>
<li><code>committed</code>：事务已经完成并成功提交。</li>
<li><code>aborted</code>：事务已经被撤销或回滚。</li>
</ul>
</li>
<li>这些状态被保存在一个特定的文件（XID 文件）中，每个事务状态占用一个字节的空间。</li>
</ul>
<h2 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于分页管理和数据项（DataItem）管理都涉及缓存，这里设计一个更通用的缓存框架。三个hashmap</p>
<p>这段代码描述的是一个高级缓存系统，采用引用计数和锁机制来管理缓存项，以适应多线程环境中的数据访问和同步需求。缓存系统由一个抽象类 <code>AbstractCache&lt;T&gt;</code> 实现，该类定义了获取和释放缓存资源的抽象方法，以及实现了资源管理的具体逻辑。这个实现确保了线程安全，并能有效处理资源的加载和释放。以下是代码的详解及其功能：</p>
<h4 id="缓存系统的组件"><a href="#缓存系统的组件" class="headerlink" title="缓存系统的组件"></a>缓存系统的组件</h4><ol>
<li><strong>缓存的数据存储 (<code>cache</code>)</strong>:<ul>
<li>用一个 <code>HashMap</code> 存储实际的缓存数据，键是资源的唯一标识符（<code>key</code>），值是资源对象（<code>T</code>）。</li>
</ul>
</li>
<li><strong>资源的引用计数 (<code>references</code>)</strong>:<ul>
<li>另一个 <code>HashMap</code> 用于追踪每个资源在缓存中的引用次数。引用计数是管理资源何时可以从缓存中安全移除的重要机制。</li>
</ul>
</li>
<li><strong>正在获取的资源标记 (<code>getting</code>)</strong>:<ul>
<li>第三个 <code>HashMap</code> 用于标记那些正被其他线程加载的资源。这防止了对同一资源的多余请求，如果一个资源正在加载中，其他请求该资源的线程会等待，而不是同时尝试加载同一个资源。</li>
</ul>
</li>
</ol>
<h4 id="缓存操作的流程"><a href="#缓存操作的流程" class="headerlink" title="缓存操作的流程"></a>缓存操作的流程</h4><p>获取资源 (<code>get()</code> 方法)</p>
<ul>
<li><p>等待其他线程加载资源</p>
<ul>
<li>如果请求的资源正在被其他线程加载（<code>getting</code> 中有记录），当前线程将等待（通过 <code>Thread.sleep</code>），直到资源可用。</li>
</ul>
</li>
<li><p>直接从缓存中获取</p>
<ul>
<li>如果资源已在缓存中，则直接返回该资源，并将该资源的引用计数增加。</li>
</ul>
</li>
<li><p>加载新资源</p>
<p>如果资源不在缓存中且缓存未满，标记资源为正在获取（在 <code>getting</code> 中设置标记），然后加载资源。</p>
<ul>
<li>如果加载成功，将资源添加到缓存，并设置引用计数为1。</li>
<li>如果加载失败，清除正在获取的标记，并处理异常。</li>
</ul>
</li>
</ul>
<p>释放资源 (<code>release()</code> 方法)</p>
<ul>
<li>减少引用计数<ul>
<li>减少指定资源的引用计数。如果引用计数降至0，则调用 <code>releaseForCache()</code> 方法将资源写回到持久存储（如果有这样的操作），并从缓存中移除该资源。</li>
</ul>
</li>
</ul>
<p>安全关闭 (<code>close()</code> 方法)</p>
<ul>
<li>强制回源并清理所有资源<ul>
<li>在关闭缓存时，遍历所有缓存项，强制释放每个资源，并清理相关数据结构。</li>
</ul>
</li>
</ul>
<h4 id="缓存的同步和线程安全"><a href="#缓存的同步和线程安全" class="headerlink" title="缓存的同步和线程安全"></a>缓存的同步和线程安全</h4><p>通过使用锁（<code>lock.lock()</code> 和 <code>lock.unlock()</code>），上述方法确保在多线程环境下对缓存的访问是线程安全的。锁的使用确保了对缓存结构的修改是互斥的，防止了数据竞争和潜在的并发错误。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个缓存框架通过抽象方法提供了灵活性，允许定制资源获取和释放的具体逻辑，而通过引用计数和锁机制提供了一种稳健的方法来管理缓存资源的生命周期和并发访问，非常适合需要高并发处理和资源管理的应用场景。</p>
<h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><p>为什么不选择lru？</p>
<p>确实，LRU（Least Recently Used）缓存策略因其简单高效在许多场景中被广泛使用。然而，引用计数策略在特定场景下可能比LRU更合适，特别是在数据库管理系统（DBMS）和其他需要精细控制资源生命周期的系统中。以下是一个例子，详细解释为什么在某些情况下选择引用计数而不是LRU。</p>
<p>场景描述</p>
<p>假设你正在开发一个视频编辑软件，该软件允许用户同时编辑多个视频片段。这些视频片段需要被频繁读取和修改，并且由于视频文件通常很大，因此使用缓存来存储当前正在编辑的片段是很有必要的。</p>
<p>问题出现</p>
<p>如果采用LRU缓存策略，最近最少使用的视频片段将会被自动驱逐出缓存，以便为新的片段腾出空间。考虑以下情形：</p>
<ol>
<li><strong>编辑工作重叠</strong>：用户可能在多个视频片段之间来回切换，对它们进行编辑。使用LRU时，一个长时间未被访问但正处于半编辑状态的视频片段可能会被驱逐。当用户返回这个片段时，他们可能会发现所有未保存的更改都已消失，因为片段被驱逐且更改未被写回磁盘。</li>
<li><strong>资源驱逐时的数据一致性问题</strong>：<ul>
<li><strong>不回源</strong>：如果不将修改过的数据写回数据源，那么所有更改都将丢失，这对于需要持久化更改的应用来说是不可接受的。</li>
<li><strong>回源</strong>：如果每次资源被驱逐时都进行回源操作，这可能导致不必要的I&#x2F;O开销，特别是当数据并未发生更改时。</li>
<li><strong>缓存抖动</strong>：频繁地将资源放回缓存并再次被驱逐（因为缓存已满），这会导致所谓的缓存抖动，降低缓存的效率。</li>
</ul>
</li>
</ol>
<p>引用计数的优势</p>
<p>使用引用计数策略，在这种情况下会更合适：</p>
<ul>
<li><strong>明确的生命周期控制</strong>：每个缓存项的生命周期清晰可控。资源只有在没有任何组件引用它时才会被释放。这为用户提供了一定的安全性，确保正在使用的资源不会被意外驱逐。</li>
<li><strong>减少不必要的写回操作</strong>：只有在确定资源不再被需要时才会被驱逐和回源，减少了不必要的磁盘I&#x2F;O操作。</li>
<li><strong>适应复杂依赖关系</strong>：在处理多个相关资源（例如，多个相互依赖的视频片段）时，引用计数可以更好地管理资源之间的依赖关系。</li>
</ul>
<p>结论</p>
<p>在选择缓存策略时，需要考虑应用的特定需求。虽然LRU提供了一种高效的通用解决方案，但在需要详细管理资源生命周期、防止数据丢失和减少不必要I&#x2F;O的情况下，引用计数可能是一个更好的选择。在视频编辑软件的场景中，引用计数可以保证用户正在工作的视频片段不会因为缓存策略而意外丢失，提高了应用的稳定性和用户的满意度。</p>
<h3 id="缓存页面"><a href="#缓存页面" class="headerlink" title="缓存页面"></a>缓存页面</h3><p>本节主要内容就是 DM 模块向下对文件系统的抽象部分。DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。</p>
<p>读取磁盘文件为缓存页面类型，插入数据之后，标记页面为脏数据，之后缓存驱逐的时候写入磁盘</p>
<p>在数据库的页面管理系统中，FSO (Free Space Offset) 是用来标识页面内第一个空闲字节的位置。这样设计的目的是为了快速找到可以插入新数据的位置。现在，让我们更详细地解释如何使用 FSO，并以 <code>Page</code> 类为例进行说明。</p>
<h4 id="FSO-Free-Space-Offset-详解"><a href="#FSO-Free-Space-Offset-详解" class="headerlink" title="FSO (Free Space Offset) 详解"></a>FSO (Free Space Offset) 详解</h4><p>初始化 FSO</p>
<p>在 <code>Page</code> 类中，FSO 被初始化为 2。这是因为页面数据的开始两个字节被用来存储 FSO 本身。FSO 是一个 <code>short</code> 类型，占用 2 字节。这意味着：</p>
<ul>
<li>从字节索引 <code>0</code> 到 <code>1</code>（共2个字节）用于存储表示空闲空间起始位置的 FSO。</li>
<li>FSO 的值为 2 表示从字节索引 <code>2</code> 开始的部分是用于存储实际数据的。</li>
</ul>
<p>插入数据的过程</p>
<p>插入数据时，<code>Page</code> 类中的 <code>insertData</code> 方法按以下步骤操作：</p>
<ol>
<li><strong>读取当前 FSO</strong>：<ul>
<li>使用 <code>getFSO</code> 方法读取存储在页面开始的两个字节中的 FSO 值。这个值告诉我们页面中空闲空间的开始位置。</li>
</ul>
</li>
<li><strong>复制新数据到 FSO 指示的位置</strong>：<ul>
<li>使用 <code>System.arraycopy</code> 方法，将新数据从源数组 <code>newData</code> 复制到 <code>Page</code> 的 <code>data</code> 数组中，复制的起始位置是当前的 FSO。</li>
<li><code>newData.length</code> 决定了要复制数据的长度。</li>
</ul>
</li>
<li><strong>更新 FSO</strong>：<ul>
<li>插入数据后，新的 FSO 将是原来的 FSO 加上新插入的数据长度 <code>newData.length</code>。这是因为新数据占据了从原 FSO 开始的一段空间。</li>
<li>更新后的 FSO 指向下一个空闲的字节，为将来的数据插入做准备。</li>
</ul>
</li>
<li><strong>设置新的 FSO 值</strong>：<ul>
<li>使用 <code>setFSO</code> 方法，将新计算的 FSO 值写回页面数据的开始两个字节中。</li>
</ul>
</li>
</ol>
<p>如何更新 FSO</p>
<p><code>setFSO</code> 方法的工作原理如下：</p>
<ul>
<li>将 <code>short</code> 类型的 FSO 值分解为两个字节。由于 Java 使用大端字节序（高字节优先），<code>offset</code> 的低字节存储在数组的第一个位置，高字节存储在第二个位置。</li>
<li><code>offset &amp; 0xFF</code> 获取 <code>offset</code> 的低字节。</li>
<li><code>(offset &gt;&gt; 8) &amp; 0xFF</code> 获取 <code>offset</code> 的高字节。</li>
<li>这两个字节被放回 <code>data</code> 数组的前两个位置，这样 FSO 就更新了。</li>
</ul>
<p>小结</p>
<p>通过这种方式，<code>Page</code> 类能有效地管理页面内的数据存储和空间分配。初始化 FSO 为 2 是因为要为存储 FSO 本身留出空间。更新 FSO 是为了维护对空闲空间的准确跟踪，确保每次数据插入后，新的空闲空间位置都能被正确记录和使用。这样的设计简化了数据插入操作，提高了数据库系统的效率和性能。</p>
<h4 id="缓存页面问题"><a href="#缓存页面问题" class="headerlink" title="缓存页面问题"></a>缓存页面问题</h4><p>如何确定数据库是否正常关闭？</p>
<p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p>
<p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h4><p>日志的二进制文件，按照如下的格式进行排布：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]</span><br></pre></td></tr></table></figure>

<p>其中 XChecksum 是一个四字节的整数，是对后续所有日志计算的校验和。Log1 ~ LogN 是常规的日志数据，BadTail 是在数据库崩溃时，没有来得及写完的日志数据，这个 BadTail 不一定存在。</p>
<p>每条日志的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Size][Checksum][Data]</span><br></pre></td></tr></table></figure>

<p>其中，Size 是一个四字节整数，标识了 Data 段的字节数。Checksum 则是该条日志的校验和。</p>
<p>在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p>
<p>向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><p>多线程</p>
<p>经过以上的操作，就能保证了 MYDB 在单线程下的恢复性。对于多线程的情况下呢？我们来考虑下面的两种情况。</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">T2 U(x)</span><br><span class="line">T1 R(x)</span><br><span class="line">...</span><br><span class="line">T1 commit</span><br><span class="line">MYDB break down</span><br></pre></td></tr></table></figure>

<p>在系统崩溃时，T2 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会撤销 T2，它对数据库的影响会被消除。但是由于 T1 读取了 T2 更新的值，既然 T2 被撤销，那么 T1 也应当被撤销。这种情况，就是级联回滚。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p>
<blockquote>
<p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p>
</blockquote>
<p>第二种情况，假设 x 的初值是 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">T1 set x = x+1 // 产生的日志为(T1, U, A, 0, 1)</span><br><span class="line">T2 set x = x+1 // 产生的日志为(T1, U, A, 1, 2)</span><br><span class="line">T2 commit</span><br><span class="line">MYDB break down</span><br></pre></td></tr></table></figure>

<p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会对 T1 进行撤销，对 T2 进行重做，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p>
<blockquote>
<p>出现这种问题的原因, 归根结底是因为我们的日志太过简单, 仅仅记录了”前相”和”后相”. 并单纯的依靠”前相”undo, 依靠”后相”redo. 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p>
</blockquote>
<p>解决方法有两种：</p>
<ol>
<li>增加日志种类</li>
<li>限制数据库操作</li>
</ol>
<p>MYDB 采用的是限制数据库操作，需要保证：</p>
<blockquote>
<p>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
</blockquote>
<p>vm 没有删除？<br>vm解决保证规定执行</p>
<h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p>页面索引，缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。</p>
<p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p>
<p>DataItem 中保存的数据，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ValidFlag] [DataSize] [Data]</span><br></pre></td></tr></table></figure>

<p>其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效。删除一个 DataItem，只需要简单地将其有效位设置为 0。DataSize 占用 2 字节，标识了后面 Data 的长度。</p>
<p>DataManager 是 DM 层直接对外提供方法的类，同时，也实现成 DataItem 对象的缓存。DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。</p>
<p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p>
<h2 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h2><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p>
<ol>
<li>两个不同事务的 U 操作冲突</li>
<li>两个不同事务的 U、R 操作冲突</li>
</ol>
<p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。</p>
<p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(x) // T1读到0</span><br><span class="line">R2(x) // T2读到0</span><br><span class="line">U1(0+1) // T1尝试把x+1</span><br><span class="line">U2(0+1) // T2尝试把x+1</span><br><span class="line">T1 commit</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>

<p>由于同时读取 最后 x 的结果是 1，这个结果显然与期望的不符。</p>
<h3 id="MVCC和2PL-可重复度和执行串行化"><a href="#MVCC和2PL-可重复度和执行串行化" class="headerlink" title="MVCC和2PL_可重复度和执行串行化"></a>MVCC和2PL_可重复度和执行串行化</h3><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。</p>
<p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<p>我们规定，一条 Entry 中存储的数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[XMIN] [XMAX] [DATA]</span><br></pre></td></tr></table></figure>

<p>XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。</p>
<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">R1(X) // T1 读得 0</span><br><span class="line">T2 begin</span><br><span class="line">U2(X) // 将 X 修改为 1</span><br><span class="line">T2 commit</span><br><span class="line">R1(X) // T1 读的 1</span><br></pre></td></tr></table></figure>

<p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。</p>
<p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p>
<blockquote>
<p>事务只能读取它开始时, 就已经结束的那些事务产生的数据版本</p>
</blockquote>
<p>这条规定，增加于，事务需要忽略：</p>
<ol>
<li>在本事务后开始的事务的数据;</li>
<li>本事务开始时还是 active 状态的事务的数据</li>
</ol>
<p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p>
<h3 id="死锁解决"><a href="#死锁解决" class="headerlink" title="死锁解决"></a>死锁解决</h3><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。</p>
<p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<h3 id="VM和DM，IM的关系"><a href="#VM和DM，IM的关系" class="headerlink" title="VM和DM，IM的关系"></a>VM和DM，IM的关系</h3><h4 id="数据操作和传输的互动"><a href="#数据操作和传输的互动" class="headerlink" title="数据操作和传输的互动"></a>数据操作和传输的互动</h4><ol>
<li><strong>事务开始时</strong>：<ul>
<li>当一个事务开始时，TM 创建一个事务上下文（包括事务ID和其他元数据），并将其标记为活动状态。</li>
<li>VM 在开始事务时，为这个事务准备一个快照，以支持MVCC，允许事务看到一致的数据视图。</li>
</ul>
</li>
<li><strong>数据读取</strong>：<ul>
<li>当事务请求读取数据时，VM 首先会查询 TM 确定当前事务的隔离级别和可见性。</li>
<li>VM 使用TM提供的信息来决定哪个版本的数据对当前事务可见，并从 DM 请求读取相应版本的数据。</li>
<li>DM 从物理存储中检索数据并返回给 VM，VM 然后再将数据返回给请求的事务。</li>
</ul>
</li>
<li><strong>数据写入</strong>：<ul>
<li>写操作首先由 VM 接收，它记录要修改的数据版本。</li>
<li>VM 可能需要与 TM 协商获取必要的锁，以防止其他并发事务对相同数据的干扰。</li>
<li>数据的新版本被写入前，先在 DM 中创建，包括所有必要的日志信息，以便在发生故障时能够恢复。</li>
<li>完成写操作后，VM 会更新数据版本，并在事务提交时通知 TM。</li>
</ul>
</li>
<li><strong>事务提交和回滚</strong>：<ul>
<li>当事务准备提交时，TM 检查所有操作是否成功，并指示 VM 和 DM 提交或回滚所有更改。</li>
<li>如果事务提交，VM 更新版本控制信息，并确认更改永久保存在 DM。</li>
<li>如果事务需要回滚，VM 指示 DM 撤销所有未提交的写操作，并恢复数据到事务开始前的状态。</li>
</ul>
</li>
</ol>
<h2 id="IM"><a href="#IM" class="headerlink" title="IM"></a>IM</h2><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。</p>
<p>在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。</p>
<p>二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[LeafFlag][KeyNumber][SiblingUid]</span><br><span class="line">[Son0][Key0][Son1][Key1]...[SonN][KeyN]</span><br></pre></td></tr></table></figure>

<p>其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID（通常是sonN+1，保证连续）。</p>
<p><strong>LeafFlag &#x3D; 0 (非叶子节点)</strong></p>
<p> <strong>KeyNumber &#x3D; 3</strong> </p>
<p><strong>SiblingUid &#x3D; 102</strong> </p>
<p><strong>Son0 &#x3D; 100, Key0 &#x3D; 15, Son1 &#x3D; 101, Key1 &#x3D; 30, Son2 &#x3D; 103, Key2 &#x3D; Long.MAX_VALUE</strong></p>
<p> <strong>这表示当前节点有三个键（15, 30, MAX_VALUE）和四个子节点（UID分别为100, 101, 103, 和对应的下一个兄弟节点102）。</strong></p>
<p>后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。key0是0-key0的范围</p>
<p>Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;</span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DM和IM的关系"><a href="#DM和IM的关系" class="headerlink" title="DM和IM的关系"></a>DM和IM的关系</h3><h4 id="DM（数据管理）"><a href="#DM（数据管理）" class="headerlink" title="DM（数据管理）"></a>DM（数据管理）</h4><p>在这个上下文中，<code>DM</code>指的是负责存储和管理实际数据的组件。在B+树实现中，每个节点的数据（包括键和指向子节点的指针）通常存储在持久化存储介质上，<code>DM</code>负责这部分数据的读写操作。<code>DataItem</code>是一个抽象，它代表存储在<code>DM</code>中的一块数据。</p>
<ul>
<li><strong>数据的读取</strong>：当<code>Node</code>需要被加载时，使用<code>DM</code>的<code>read</code>方法通过节点的唯一标识符（UID）来获取对应的<code>DataItem</code>。例如，<code>loadNode</code>方法在<code>Node</code>类中用于根据UID加载节点，这包括从<code>DM</code>中读取数据并解析为<code>Node</code>的内部表示。</li>
<li><strong>数据的写入</strong>：当节点数据需要更新或新增时，<code>DM</code>同样负责写入这些更改。例如，在节点分裂时，新节点的数据需要被写入存储系统，这通过<code>DM</code>的<code>insert</code>方法完成，它返回新节点的UID。</li>
</ul>
<h4 id="IM（索引管理）"><a href="#IM（索引管理）" class="headerlink" title="IM（索引管理）"></a>IM（索引管理）</h4><p><code>IM</code>则是管理索引的部分，主要负责使用这些数据项（<code>DataItem</code>）来维护和更新索引结构。在这个Java类实现中，<code>Node</code>类本身可以视为<code>IM</code>的一部分，因为它直接处理与索引相关的所有逻辑，包括搜索、插入和分割等操作。</p>
<h4 id="数据的添加和获取"><a href="#数据的添加和获取" class="headerlink" title="数据的添加和获取"></a>数据的添加和获取</h4><ol>
<li><strong>添加数据</strong>：<ul>
<li>插入新键或新子节点时，例如<code>insertAndSplit</code>方法中，<code>Node</code>首先计算插入位置，然后调整现有的键和子节点UIDs，必要时进行节点分裂，并将更改写回到<code>DM</code>。</li>
</ul>
</li>
<li><strong>获取数据</strong>：<ul>
<li>当需要找到一个键对应的子节点时，<code>searchNext</code>方法被调用。这个方法通过比较节点中存储的键来确定应该访问的子节点的UID。</li>
<li><code>leafSearchRange</code>方法用于执行范围搜索，它返回一个键范围内的所有相关子节点的UID列表。</li>
</ul>
</li>
</ol>
<p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。</p>
<p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。</p>
<h2 id="TBM"><a href="#TBM" class="headerlink" title="TBM"></a>TBM</h2><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>这个 <code>Tokenizer</code> 类是一个文本解析器，主要用于从一个字节流（例如字符串的字节表示）中提取语义上有意义的标记（tokens）。该解析器能够处理空白字符、标点符号、引号包裹的字符串以及字母数字组成的词。这样的解析器常见于编程语言的编译器、解释器或任何需要从文本输入中提取信息的软件中。</p>
<p>使用Parser类来对获取到的对应字段进行操作解析对应的语句<br>最后返回定义的参数</p>
<h3 id="TBM和IM和VM的关系"><a href="#TBM和IM和VM的关系" class="headerlink" title="TBM和IM和VM的关系"></a>TBM和IM和VM的关系</h3><ol>
<li><p><strong>表的创建和管理</strong>：</p>
<ul>
<li>当 TBM 创建新表时，它将表的定义（包括表名和字段信息等）存储在 VM 中。这通常涉及编码表的结构到一个字节流中，并将这个字节流保存在持久化存储中。</li>
<li>如果表的字段具有索引，TBM 将调用 IM 来创建这些索引。索引的创建包括确定索引的类型（如 B+树），并将索引的根存储在字段定义中。</li>
</ul>
</li>
<li><p><strong>数据查询和修改</strong>：</p>
<ul>
<li><p>当执行查询（如 SELECT）时，TBM 可能需要利用 IM 提供的索引来快速定位数据。这涉及到读取字段的索引信息，并通过索引快速找到数据的存储位置。</p>
</li>
<li><p>更新或删除操作可能需要修改索引结构，这时 TBM 将指导 IM 调整索引以反映数据的变更。</p>
</li>
</ul>
</li>
</ol>
<h2 id="CS-BS"><a href="#CS-BS" class="headerlink" title="CS&#x2F;BS"></a>CS&#x2F;BS</h2><p>在您的系统中，Server 和 Client 分别扮演数据库服务提供者和消费者的角色。他们通过使用 Java 套接字（Socket）进行通信，实现命令的发送和数据的接收。这里的实现借助几个关键类：<code>Packager</code>，<code>Transporter</code>，和 <code>Encoder</code>，以及两个入口类 <code>Launcher</code> 用于启动服务器和客户端。下面我将详细解释这些组件的作用和数据传输过程，并给出一个具体的使用例子。</p>
<h3 id="Server-的作用和实现"><a href="#Server-的作用和实现" class="headerlink" title="Server 的作用和实现"></a>Server 的作用和实现</h3><p><strong>作用</strong>：</p>
<ul>
<li>监听一个端口，接收来自客户端的连接请求。</li>
<li>对每个客户端请求，创建一个新线程（通过 <code>ClientHandler</code> 类）来处理。</li>
<li>解析客户端发送的 SQL 命令，执行这些命令，并将结果返回给客户端。</li>
</ul>
<p><strong>实现</strong>：</p>
<ul>
<li><code>Server</code> 类使用 <code>ServerSocket</code> 来监听指定端口的连接请求。一旦有客户端连接，就创建一个新线程来处理该连接。</li>
<li>在处理线程中（<code>ClientHandler</code>），通过 <code>Packager</code> 类来接收和发送数据包（<code>Package</code>）。</li>
</ul>
<h3 id="Client-的作用和实现"><a href="#Client-的作用和实现" class="headerlink" title="Client 的作用和实现"></a>Client 的作用和实现</h3><p><strong>作用</strong>：</p>
<ul>
<li>连接到服务器。</li>
<li>发送 SQL 命令到服务器，并接收执行结果。</li>
</ul>
<p><strong>实现</strong>：</p>
<ul>
<li><code>Client</code> 类通过套接字连接到服务器，并使用 <code>Packager</code> 来发送和接收数据包。</li>
<li>提供 <code>execute</code> 方法来发送 SQL 命令并接收结果。</li>
</ul>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ol>
<li><strong>编码和发送</strong>：<ul>
<li>客户端通过 <code>Encoder</code> 类将 SQL 命令编码为二进制数据，封装在 <code>Package</code> 对象中。</li>
<li><code>Packager</code> 类通过 <code>Transporter</code> 将数据包发送出去。数据在发送前会被转换为十六进制字符串以避免特殊字符问题，并通过套接字发送。</li>
</ul>
</li>
<li><strong>接收和解码</strong>：<ul>
<li>服务器接收到数据后，通过 <code>Transporter</code> 读取数据，然后使用 <code>Encoder</code> 解码。</li>
<li>解码后的数据包含 SQL 命令，服务器执行这些命令，并将结果（或错误信息）再次通过 <code>Encoder</code> 编码后返回给客户端。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>MYDB</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode配置以及算法的学习思路</title>
    <url>/2024/02/16/VsCode%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1-VsCode配置方法"><a href="#1-VsCode配置方法" class="headerlink" title="1.VsCode配置方法"></a>1.VsCode配置方法</h2><p>先用的这个： </p>
<p><a href="https://www.cnblogs.com/Neal-lee/p/13512084.html">https://www.cnblogs.com/Neal-lee/p/13512084.html</a></p>
<p>（可能不需要上面的）</p>
<p>之后是拿这个成功的：</p>
<p><a href="https://blog.csdn.net/davidhopper/article/details/79397487">https://blog.csdn.net/davidhopper/article/details/79397487</a></p>
<p>下面是一些我的电脑的配置细节，你们按照上面走就可以，像安装过dev，就可以直接找到MinGw，不需要再下。</p>
<h4 id="但是但是："><a href="#但是但是：" class="headerlink" title="但是但是："></a>但是但是：</h4><p>dev的那个用的c++太落后了</p>
<p>就vector和 迭代器以及vescode的bug就又得重搞mingw</p>
<p>之后我是跟着这个走的：<a href="https://blog.csdn.net/qq_33472553/article/details/96580127">https://blog.csdn.net/qq_33472553/article/details/96580127</a></p>
<p>要注意的是：要把环境变量的原来的dev那个给删掉      —–</p>
<p>搞这搞了两天搞死我了—-chao</p>
<p>system(“pause”);</p>
<p>可以让黑框框停留下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  </span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">  </span><br><span class="line">      &#123;</span><br><span class="line">  </span><br><span class="line">        &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示</span><br><span class="line">  </span><br><span class="line">        &quot;type&quot;: &quot;cppdbg&quot;,    // 配置类型，这里只能为cppdbg</span><br><span class="line">  </span><br><span class="line">        &quot;request&quot;: &quot;launch&quot;,   // 请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class="line">  </span><br><span class="line">        &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,// 将要进行调试的程序的路径</span><br><span class="line">  </span><br><span class="line">        &quot;args&quot;: [],       // 程序调试时传递给程序的命令行参数，一般设为空即可</span><br><span class="line">  </span><br><span class="line">        &quot;stopAtEntry&quot;: false,  // 设为true时程序将暂停在程序入口处，一般设置为false</span><br><span class="line">  </span><br><span class="line">        &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录</span><br><span class="line">  </span><br><span class="line">        &quot;environment&quot;: [],</span><br><span class="line">  </span><br><span class="line">        &quot;externalConsole&quot;: true,// 调试时是否显示控制台窗口，一般设置为true显示控制台</span><br><span class="line">  </span><br><span class="line">        &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">  </span><br><span class="line">        &quot;miDebuggerPath&quot;: &quot;C:\\Program Files (x86)\\Dev-Cpp\\MinGW64\\bin\\gdb.exe&quot;,// miDebugger的路径，注意这里要与MinGw的路径对应</span><br><span class="line">  </span><br><span class="line">        &quot;preLaunchTask&quot;: &quot;g++&quot;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span><br><span class="line">  </span><br><span class="line">        &quot;setupCommands&quot;: [</span><br><span class="line">  </span><br><span class="line">          &#123;</span><br><span class="line">  </span><br><span class="line">            &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">  </span><br><span class="line">            &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">  </span><br><span class="line">            &quot;ignoreFailures&quot;: true</span><br><span class="line">  </span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">        ]</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    ]</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks.json</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">    &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;-g&quot;,&quot;$&#123;file&#125;&quot;,&quot;-o&quot;,&quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;], // 编译命令参数</span><br><span class="line">    &quot;problemMatcher&quot;: &#123;</span><br><span class="line">        &quot;owner&quot;: &quot;cpp&quot;,</span><br><span class="line">        &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;$&#123;workspaceRoot&#125;&quot;],</span><br><span class="line">        &quot;pattern&quot;: &#123;</span><br><span class="line">            &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;,</span><br><span class="line">            &quot;file&quot;: 1,</span><br><span class="line">            &quot;line&quot;: 2,</span><br><span class="line">            &quot;column&quot;: 3,</span><br><span class="line">            &quot;severity&quot;: 4,</span><br><span class="line">            &quot;message&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ctrl+F2选中所有一样的</p>
<p>设置里面可以改字号</p>
<p>shift+alt+F 自动缩进</p>
<p>以上就是当初配置vscode编写c++的配置过程，下面是当初刚开始接触算法题时候的算法笔记吧（算是</p>
<h2 id="2-bfs经典例题"><a href="#2-bfs经典例题" class="headerlink" title="2.bfs经典例题"></a>2.bfs经典例题</h2><p>—躲障碍—</p>
<p><strong>暑期集训的一天下了大雨，地面出现了许多泥坑，一踩一脚泥。小tao从坐标平面上的点（0，0）出发，准备去向文瀛餐厅（X , Y）（-500≤ X , Y≤ 500)。在路上有N(1≤ N≤ 10000）个泥坑，位于点（Ai，Bi）（-500≤ Ai , Bi≤500)。</strong></p>
<p><strong>小tao为了好好集训，买了一双新鞋子来鼓舞自己，他不想弄脏鞋子，但他也想尽快到达餐厅干饭。如果小tao只能平行于轴线移动，并在整数坐标点转向，请问他到达餐厅且保持鞋子干净要走的最小距离是多少？</strong></p>
<p><strong>保证总是有一条没有泥的路使得小tao可以走到餐厅。</strong></p>
<p><strong>输入： 第1行：三个空间分隔的整数：X、Y和N。 表示餐厅坐标以及泥坑的数量。</strong></p>
<p><strong>第2..N+1行：第i+1行包含两个空格分隔的整数：Ai和Bi。 表示每个泥坑的坐标。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 7</span><br><span class="line">0 2</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">-1 1</span><br><span class="line">-1 3</span><br></pre></td></tr></table></figure>

<p><strong>输出：输出小tao在不踩泥的情况下到达文瀛餐厅所需的最小距离。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h4 id="代码c-："><a href="#代码c-：" class="headerlink" title="代码c++："></a>代码c++：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"> <span class="type">int</span> x,y,l;<span class="comment">//这里的l表示到坐标为（x,y)的步数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> vis[maxn][maxn];<span class="comment">//判断是否跑过了 </span></span><br><span class="line"><span class="type">int</span> map[maxn][maxn];<span class="comment">//判断障碍</span></span><br><span class="line"><span class="comment">//判断是否越界，判断是否有障碍物；</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;=<span class="number">1000</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">1000</span>&amp;&amp;!vis[x][y]&amp;&amp;!map[x][y])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"> queue&lt;node&gt;q;<span class="comment">//创建队列，&lt;&gt;这里面是类型，q是这个队列的总名</span></span><br><span class="line"> node s;s.x=<span class="number">500</span>,s.y =<span class="number">500</span>,s.l =<span class="number">0</span>;</span><br><span class="line"> q.<span class="built_in">push</span>(s);</span><br><span class="line"> vis[s.x ][s.y ]=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">     <span class="comment">//读取进去的，然后抛弃他</span></span><br><span class="line">  node u=q.<span class="built_in">front</span>() ;q.<span class="built_in">pop</span>() ;</span><br><span class="line">  <span class="keyword">if</span>(u.x ==m&amp;&amp;u.y ==n)&#123;</span><br><span class="line">      <span class="comment">//满足的时候返回路的数值</span></span><br><span class="line">   <span class="keyword">return</span> u.l ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">   <span class="type">int</span> tx=u.x +dx[i];</span><br><span class="line">   <span class="type">int</span> ty=u.y +dy[i];</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">check</span>(tx,ty))&#123;</span><br><span class="line">    node temp;temp.x =tx;temp.y =ty;</span><br><span class="line">    temp.l =u.l+<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//满足条件的话，可以往队例里边加入新的模块</span></span><br><span class="line">    q.<span class="built_in">push</span>(temp);</span><br><span class="line">    vis[tx][ty]=<span class="number">1</span>;  </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> Y1,X1,NN;</span><br><span class="line">    <span class="comment">//题目要求范围是500~-500，所以</span></span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n&gt;&gt;NN;</span><br><span class="line">	m=m+<span class="number">500</span>;n=n+<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NN;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;X1&gt;&gt;Y1;</span><br><span class="line">		map[X1+<span class="number">500</span>][Y1+<span class="number">500</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"> cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="代码java："><a href="#代码java：" class="headerlink" title="代码java："></a>代码java：</h4><p>java队列函数和C++不一样：</p>
<p>.add（）添加一组数据尾部</p>
<p>.firstNode()取第一组数据，不删</p>
<p>.poll() <strong>&#x2F;</strong>.pop() 取第一组，删除</p>
<p>.size()有几组值</p>
<p>.removeFirst()删除第一组数据</p>
<p><strong>.push()往最前面插入一组值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"> <span class="comment">//在java中，LinkedList实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。LinkedList是实现了List接口和Deque接口的双向链表</span></span><br><span class="line"> <span class="comment">//所以本题用LinkedList代替Queue。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList&lt;Q&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Main.Q&gt;();<span class="comment">//que为队列的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">		<span class="type">int</span> l;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,m,maxn=<span class="number">1005</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> dx[]=&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> vis[][]= <span class="keyword">new</span> <span class="title class_">boolean</span> [maxn][maxn];<span class="comment">//判断是否跑过了 </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> map[][] = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][maxn];<span class="comment">//判断障碍</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;=<span class="number">1000</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">1000</span>&amp;&amp;!vis[x][y]&amp;&amp;map[x][y]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">		 	Q s=<span class="keyword">new</span> <span class="title class_">Q</span>();<span class="comment">//这代表的是创建一个队列对象</span></span><br><span class="line">			 s.x=<span class="number">500</span>;s.y =<span class="number">500</span>;s.l =<span class="number">0</span>;</span><br><span class="line">			 que.add(s);</span><br><span class="line">			 vis[s.x ][s.y ]=<span class="literal">true</span>;</span><br><span class="line">			 <span class="keyword">while</span>(que.size()!=<span class="number">0</span> )&#123;</span><br><span class="line">				 Q u=que.poll();</span><br><span class="line">			  <span class="keyword">if</span>(u.x ==m&amp;&amp;u.y ==n)&#123;</span><br><span class="line">			   <span class="keyword">return</span> u.l ;</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			   <span class="type">int</span> tx=u.x +dx[i];</span><br><span class="line">			   <span class="type">int</span> ty=u.y +dy[i];</span><br><span class="line">			   <span class="keyword">if</span>(check(tx,ty))&#123;</span><br><span class="line">				   Q temp=<span class="keyword">new</span> <span class="title class_">Q</span>();temp.x =tx;temp.y =ty;</span><br><span class="line">			    temp.l =u.l+<span class="number">1</span>;</span><br><span class="line">			    que.add(temp);</span><br><span class="line">			    vis[tx][ty]=<span class="literal">true</span>;  </span><br><span class="line">			   &#125;</span><br><span class="line">			  &#125;</span><br><span class="line">			 &#125; </span><br><span class="line">			 <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> Y1,X1,NN;</span><br><span class="line">		m = scanner.nextInt();</span><br><span class="line">		n = scanner.nextInt();</span><br><span class="line">		NN = scanner.nextInt();</span><br><span class="line">		m=m+<span class="number">500</span>;n=n+<span class="number">500</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NN;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			X1 = scanner.nextInt();</span><br><span class="line">			Y1 = scanner.nextInt();</span><br><span class="line">			map[X1+<span class="number">500</span>][Y1+<span class="number">500</span>]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	System.out.println(bfs());</span><br><span class="line">		 </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-dfs例题"><a href="#3-dfs例题" class="headerlink" title="3.dfs例题"></a>3.dfs例题</h2><p>———-八皇后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Isdanger</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span>[][]C2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(C2[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((((row+col)==(i+j))||((row-col)==(i-j)))&amp;&amp;C2[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n=<span class="number">8</span>,count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> C1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                C1[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        putchess(<span class="number">0</span>,C1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putchess</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> [][]C1)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][]C2 = (<span class="type">int</span>[][])C1.clone();</span><br><span class="line">        <span class="keyword">if</span>(row==n)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 &quot;</span>+count+<span class="string">&quot; 种 &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(C2[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Isdanger(row, i, C2)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        C2[row][j]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    C2[row][i]=<span class="number">1</span>;</span><br><span class="line">                    putchess(row+<span class="number">1</span>, C2);<span class="comment">//不要忘了递归要返回的，之前想不通的第一个矩阵如何到第二个矩阵的，就是因为它可以回溯，先到达最深，再回溯到倒数第二，以此倒着不断判定所有可能情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深搜（隐式地）利用了栈（后进先出）进行计算，所以我的方法可能可以改进</p>
<h2 id="4-KMP学习思路"><a href="#4-KMP学习思路" class="headerlink" title="4.KMP学习思路"></a>4.KMP学习思路</h2><p>不要尝试去反推</p>
<p><strong>推荐学习网址</strong>：<a href="https://www.cnblogs.com/-citywall123/p/11688576.html%EF%BC%9B">https://www.cnblogs.com/-citywall123/p/11688576.html；</a></p>
<p><strong>注意</strong>：<strong>在有符号整型和无符号整型的比较中，自动将有符号整型数转换为无符号整型。</strong></p>
<h4 id="C-方法："><a href="#C-方法：" class="headerlink" title="C++方法："></a>C++方法：</h4><p>不要尝试理解kmp算法，与递归同理</p>
<p>下面是求<strong>Next</strong>数组的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1008</span>;  </span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> Next[n];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=s.<span class="built_in">length</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s[j])</span><br><span class="line">		&#123;</span><br><span class="line">			Next[++i]=++j;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j=Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="built_in">aa</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Next[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面是全的代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> next1[n];</span><br><span class="line">string re;</span><br><span class="line">string te;</span><br><span class="line"><span class="type">int</span> re1,te1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">-1</span>;</span><br><span class="line">	next1[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//	i在前面，j在后面 </span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;te1)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span>(j==<span class="number">-1</span>||te[i]==te[j])</span><br><span class="line">	&#123;</span><br><span class="line">		next1[++i]=++j;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		j=next1[j];</span><br><span class="line">	&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_piace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;re1&amp;&amp;j&lt;te1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||te[j]==re[i])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j=next1[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j&gt;=te1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> i-te1+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;re&gt;&gt;te;</span><br><span class="line">	re1=re.<span class="built_in">size</span>();</span><br><span class="line">	te1=te.<span class="built_in">length</span>();</span><br><span class="line">	<span class="built_in">get_ne</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;查找到的位置初始是：&quot;</span>&lt;&lt;<span class="built_in">get_piace</span>()&lt;&lt;endl<span class="comment">//由一开始的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h4 id="java方法："><a href="#java方法：" class="headerlink" title="java方法："></a><strong>java方法：</strong></h4><p>实际上没啥区别，就再写一遍而已：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span><span class="number">1000000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> Next[] =<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> TE[] =<span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> RE[] =<span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> re1;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> te1;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String re;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String te;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get_next</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=-<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		Next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;te1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==-<span class="number">1</span>||TE[i]==TE[j])</span><br><span class="line">			&#123;</span><br><span class="line">				Next[++i]=++j;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				j=Next[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get_piace</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;re1&amp;&amp;j&lt;te1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==-<span class="number">1</span>||TE[j]==RE[i])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			j=Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=te1)<span class="comment">//这里当时没写等号          </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i-te1+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		re=scanner.nextLine();</span><br><span class="line">		te=scanner.nextLine();</span><br><span class="line">		RE=re.toCharArray();</span><br><span class="line">		TE=te.toCharArray();</span><br><span class="line">		re1 = re.length();</span><br><span class="line">		te1 = te.length();</span><br><span class="line">		get_next();</span><br><span class="line">		System.out.println(get_piace());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>算法</category>
        <category>算法初始</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务基本命令</title>
    <url>/2024/02/16/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-windows端口显示和关闭"><a href="#1-windows端口显示和关闭" class="headerlink" title="1.windows端口显示和关闭"></a>1.windows端口显示和关闭</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">显示端口</span><br><span class="line">netstat -ano | findstr <span class="number">80</span></span><br><span class="line"></span><br><span class="line">关闭端口</span><br><span class="line">taskkill -PID <span class="number">25264</span> -F </span><br></pre></td></tr></table></figure>



<h2 id="2-linux基本命令"><a href="#2-linux基本命令" class="headerlink" title="2.linux基本命令"></a>2.linux基本命令</h2><p>[2.0 腾讯云服务器](#2.0 腾讯云服务器)</p>
<p><a href="#2.1.linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4">2.1.linux防火墙命令</a></p>
<p><a href="#2.2%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">2.2基本命令</a></p>
<h4 id="2-0-腾讯云服务器"><a href="#2-0-腾讯云服务器" class="headerlink" title="2.0 腾讯云服务器"></a>2.0 腾讯云服务器</h4><h4 id="2022-10月到期-密码：-50-x33-50-57-x36-54-x30-57-54-57-64-x71-113-x2e-x63-111-109"><a href="#2022-10月到期-密码：-50-x33-50-57-x36-54-x30-57-54-57-64-x71-113-x2e-x63-111-109" class="headerlink" title="-2022.10月到期-密码：&#50;&#x33;&#50;&#57;&#x36;&#54;&#x30;&#57;&#54;&#57;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#109;"></a>-2022.10月到期-密码：<a href="mailto:&#50;&#x33;&#50;&#57;&#x36;&#54;&#x30;&#57;&#54;&#57;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#109;">&#50;&#x33;&#50;&#57;&#x36;&#54;&#x30;&#57;&#54;&#57;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a></h4><h4 id="地址：121-5-164-60"><a href="#地址：121-5-164-60" class="headerlink" title="-地址：121.5.164.60"></a>-地址：121.5.164.60</h4><h4 id="2-1-linux防火墙命令"><a href="#2-1-linux防火墙命令" class="headerlink" title="2.1.linux防火墙命令"></a>2.1.linux防火墙命令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、开启防火墙 --关闭</span><br><span class="line">    systemctl start firewalld</span><br><span class="line">    systemctl stop firewalld.service</span><br><span class="line">    systemctl status firewalld </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、开放指定端口</span><br><span class="line">      firewall-cmd --zone=public --add-port=<span class="number">1935</span>/tcp --permanent</span><br><span class="line"> 命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port=<span class="number">1935</span>/tcp  #添加端口，格式为：端口/通讯协议</span><br><span class="line">--permanent  #永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、重启防火墙</span><br><span class="line">      firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、查看端口号</span><br><span class="line">netstat -ntlp   <span class="comment">//查看当前所有tcp端口·</span></span><br><span class="line"></span><br><span class="line">netstat -ntulp |grep <span class="number">1935</span>   <span class="comment">//查看所有1935端口使用情况·</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>列出所有开放</span><br><span class="line">firewall-cmd --<span class="built_in">list</span>-all --permanent</span><br></pre></td></tr></table></figure>

<h4 id="2-2基本命令"><a href="#2-2基本命令" class="headerlink" title="2.2基本命令"></a>2.2基本命令</h4><p>在linux里跑名为springboot-03-0.0.1-SNAPSHOT.jar的程序，把日志写到temp1.txt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar springboot-03-0.0.1-SNAPSHOT.jar &gt;temp1.txt &amp;</span><br></pre></td></tr></table></figure>

<p>查看端口号和杀死进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo lsof -i:8080</span><br><span class="line"></span><br><span class="line">sudo kill -9 474156</span><br></pre></td></tr></table></figure>

<p>文件互通-导入-导出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install lszrz</span><br><span class="line">rz</span><br><span class="line">sz</span><br></pre></td></tr></table></figure>

<p>单个删除-批量删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个删除：rm -f + 文件名</span><br><span class="line"></span><br><span class="line">批量删除：rm -f + *文件关键字* </span><br></pre></td></tr></table></figure>

<p>vim编辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim+文件名</span><br><span class="line">i 进入编辑模式</span><br><span class="line">Esc：退出编辑模式</span><br><span class="line">：wq 保存退出</span><br><span class="line">：q直接退出</span><br></pre></td></tr></table></figure>

<p>jdk位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/usr/lib/jvm/java<span class="number">-11</span>-openjdk<span class="number">-11.0</span><span class="number">.13</span><span class="number">.0</span><span class="number">.8</span><span class="number">-4.</span>el8_5.x86_64/bin/java</span><br></pre></td></tr></table></figure>

<p>文件操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir 新建文件夹</span><br><span class="line">cat 进入文件</span><br><span class="line">touch 创建文件</span><br><span class="line">mv +文件名+文件名1  改名为文件名1</span><br><span class="line">mv +文件名+路径  移动位置</span><br><span class="line">cp +文件名+路径  复制文件到</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf</span><br></pre></td></tr></table></figure>

<p>寻找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name redis-benchmark</span><br></pre></td></tr></table></figure>



<h2 id="3-docker基本命令"><a href="#3-docker基本命令" class="headerlink" title="3.docker基本命令"></a>3.docker基本命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker: 启动docker</span><br><span class="line">sudo systemctl enable docker: 开机自启</span><br><span class="line">docker update mysql8 --restart=always  自启</span><br><span class="line">docker 镜像加速阿里云</span><br><span class="line">docker search: ---------搜索</span><br><span class="line">docker pull：  ------------拉取</span><br><span class="line">docker images :   ----显示所有镜像</span><br><span class="line">docker ps ： ------显示在跑的所有容器</span><br><span class="line">docker ps -a ： -----------显示所有容器</span><br><span class="line">docker inspect 容器id： ----------显示容器详细信息</span><br><span class="line"></span><br><span class="line">docker run -it -v 主机目录：容器目录 ：---------数据卷 数据互通</span><br><span class="line"># 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span><br><span class="line">-v  容器内路径                   # 匿名挂载</span><br><span class="line">-v  卷名:容器内路径               # 具名挂载</span><br><span class="line">-v /主机路径:容器内路径            # 指定路径挂载</span><br><span class="line"></span><br><span class="line">docker run -d -p 3344:8080 --name tomcat01 tomcat:--- </span><br><span class="line">-d 后台挂载 -p 指定端口 -P随机端口  -name 指定名字 -e 设置密码啥的</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名：[TAG]: ---提交容器成为新的版本</span><br><span class="line">daocker rmi -f + ID ：---删除镜像</span><br><span class="line">docker rm -f + ID： ---- 删除容器</span><br><span class="line">docker exec -it + ID + /bin/bash ：-----再开一个命令行</span><br><span class="line">docker attach + ID :------------进入正在跑的命令行</span><br><span class="line">docker start 容器id         :  # 启动容器</span><br><span class="line">docker restart 容器id       :  # 重启容器</span><br><span class="line">docker stop 容器id          :  # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id         :   # 强制停止当前的容器</span><br><span class="line">exit        :——————退出结束进程</span><br><span class="line">Ctrl + P + Q  :——————————退出不结束进程</span><br><span class="line">docker cp 容器id：容器内路径    目的地主机路径 : ——————————————cv到外部</span><br><span class="line">curl localhost:3344   ---------------测试端口</span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet :------------创建网络</span><br><span class="line">docker network ls :显示网络</span><br><span class="line"></span><br><span class="line">docker tag diytomcat 1314520007/tomcat:1.0  :</span><br><span class="line">---------新加一个容器改变名字为1314520007/tomcat 版本为1.0，在push要记得名字要和库一样</span><br><span class="line">docker build -f mydockerfile -t mycentos:0.1 .  :---------------构建镜像</span><br><span class="line">docker build -t springboot1 .  :---------------当文件为Dockerfile时不用-f 指定 </span><br></pre></td></tr></table></figure>



<h2 id="4-mysql-状态和启动"><a href="#4-mysql-状态和启动" class="headerlink" title="4.mysql 状态和启动"></a>4.mysql 状态和启动</h2><p>（下面的腾讯云服务器当时没续费，仅做参考，天天被黑，所以配置的ip白名单</p>
<p>—腾讯云密码：324m&gt;sklG1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<p>修改密码：<a href="https://www.cnblogs.com/shigfdengys/p/12152508.html">https://www.cnblogs.com/shigfdengys/p/12152508.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password &quot;324m&gt;sklG1&quot;</span><br></pre></td></tr></table></figure>

<p>服务器白名单</p>
<p>39.144.96.201 &#x2F;&#x2F;皮卡丘</p>
<p>59.49.34.10</p>
<p>182.200.222.48</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">//查询</span><br><span class="line">select Host,User from user;</span><br><span class="line">//删除</span><br><span class="line">//DELETE FROM user WHERE User=&#x27;username&#x27; and Host=&#x27;host&#x27;;</span><br><span class="line">drop user root@&#x27;%&#x27;;//这个比较好</span><br><span class="line">//添加</span><br><span class="line">create user root@&#x27;182.200.222.48&#x27; identified by &#x27;324m&gt;sklG1&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;182.200.222.48&#x27;; </span><br><span class="line">//grant all privileges on test.* to root@&#x27;202.99.210.140&#x27;;</span><br><span class="line">//刷新权限</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;182.200.222.48&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;324m&gt;sklG1&#x27;;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>ALTER USER ‘root‘@202.99.210.140’ IDENTIFIED WITH mysql_native_password BY ‘324m&gt;sklG1’;</p>
<h2 id="5-redis"><a href="#5-redis" class="headerlink" title="5.redis"></a>5.redis</h2><p><a href="#5.1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">5.1基本命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys *</span><br><span class="line"></span><br><span class="line">flushdb</span><br><span class="line"></span><br><span class="line">flushall</span><br><span class="line"></span><br><span class="line">set key value # set值</span><br><span class="line"></span><br><span class="line">keys * #查看当前db的所有key</span><br><span class="line"></span><br><span class="line">get key # 得到key的value</span><br><span class="line"></span><br><span class="line">exists key # 是否存在key（键）</span><br><span class="line"></span><br><span class="line">move key db # 移动键到另外一个数据库，共有16个数据库，默认为0</span><br><span class="line"></span><br><span class="line">expire key 秒数 # 设置过期时间，单位是秒</span><br><span class="line"></span><br><span class="line">ttl key # 查看还有多少时间过期</span><br><span class="line"></span><br><span class="line">type key # 查看key的具体类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>持久化</p>
<p>aof 默认不开启 保存命令</p>
<p>gdb 默认开启 保存数据集</p>
<p>远程连接记得</p>
<p>1.屏蔽配置文件的bind</p>
<p>2.protect-mode设置为no</p>
<p>启动–使用的哪个配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server mconfig/redis.conf</span><br><span class="line">redis-cli -p 6379</span><br></pre></td></tr></table></figure>

<p>退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown</span><br><span class="line"> exit</span><br></pre></td></tr></table></figure>

<p>查看进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tunple | grep 6379</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span></span><br><span class="line">布隆过滤器-----缓存穿透</span><br></pre></td></tr></table></figure>

<p>sentinel monitor myredis  127.0.0.1 6379 1</p>
<p>sentinel auth-pass myredis 123456</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>云服务命令</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/02/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>跨域操作的解决方法</title>
    <url>/2024/03/21/%E8%B7%A8%E5%9F%9F%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p>
<p><img src="https://blog-img-mbt321.oss-cn-beijing.aliyuncs.com/img/image-20240321001946936.png" alt="image-20240321001946936"></p>
<h2 id="2-跨域的解决方案"><a href="#2-跨域的解决方案" class="headerlink" title="2.跨域的解决方案"></a>2.跨域的解决方案</h2><h4 id="一、SpringBoot-通过注解解决跨域"><a href="#一、SpringBoot-通过注解解决跨域" class="headerlink" title="一、SpringBoot 通过注解解决跨域"></a>一、SpringBoot 通过注解解决跨域</h4><p>可以在我们的控制器类或控制器方法上添加，添加在类上表示里面所有方法都可跨域，添加在方法上表示指定方法可以跨域，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、SpringBoot-配置-CORS-解决跨域"><a href="#二、SpringBoot-配置-CORS-解决跨域" class="headerlink" title="二、SpringBoot 配置 CORS 解决跨域"></a>二、SpringBoot 配置 CORS 解决跨域</h4><p>即在我们所有响应头配置允许跨域访问，CORS也已经成为主流的跨域解决方案。</p>
<ol>
<li>在项目中创建一个新的配置文件</li>
<li>添加<code>@Configuration</code>注解实现<code>WebMvcConfigurer</code>接口</li>
<li>重写<code>addCorsMappings</code>方法并设置允许跨域的代码</li>
</ol>
<h4 id="三、SpringBoot-通过-CorsFilter-解决跨域"><a href="#三、SpringBoot-通过-CorsFilter-解决跨域" class="headerlink" title="三、SpringBoot 通过 CorsFilter 解决跨域"></a>三、SpringBoot 通过 CorsFilter 解决跨域</h4><p>这种方式和上面的方式类似，但是主要是通过过滤器进行跨域，也是通过<code>Java Config</code>的方式配置跨域访问，具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCorsFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建 CORS 配置对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 支持域</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 支持请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的原始请求头部信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 暴露的头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.添加地址映射</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">corsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="comment">// 3.返回 CorsFilter 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(corsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、通过-nginx-配置-CORS-解决跨域"><a href="#四、通过-nginx-配置-CORS-解决跨域" class="headerlink" title="四、通过 nginx 配置 CORS 解决跨域"></a>四、通过 nginx 配置 CORS 解决跨域</h4><p>如果我们项目有用 <code>nginx</code> 做反向代理服务器时，也可以在<code>nginx</code>中配置<code>CORS</code>来解决跨域</p>
<p><strong>问：什么是nginx反向代理？如何实现跨域的？</strong></p>
<p><strong>正向代理</strong> :a-&gt;b-&gt;c   a是客户端想访问c，通过代理服务器b来访问外网服务器c  </p>
<p>–所以，正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。–</p>
<p>正向代理的好处有：</p>
<p>​	1.可以突破访问自身ip限制</p>
<p>​	2.由于代理服务器中有较大的硬盘缓存区，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。 </p>
<p>​	3.隐藏客户端真实IP</p>
<p><strong>反向代理：</strong>a-&gt;b–冒充–c a想访问c ，但是b代理了c，给a返回结果</p>
<p>–所以，反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。–</p>
<p>反向代理的好处:</p>
<p>​		1.实现负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p>
<p>​		2.提高访问速度， 反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p>
<p>​		3.隐藏服务器真实ip</p>
<h2 id="3-综合比较"><a href="#3-综合比较" class="headerlink" title="3.综合比较"></a>3.综合比较</h2><ul>
<li><strong>简便性</strong>：注解方式最为简单，适合快速开发或小型项目。</li>
<li><strong>集中管理与控制力</strong>：通过配置文件或<code>CorsFilter</code>能更集中地管理跨域策略，适合中大型项目。</li>
<li><strong>性能与透明性</strong>：nginx配置最优，适合需要高性能和有nginx环境的项目。</li>
</ul>
<p>​		</p>
<p>​		选择哪种方案取决于项目的具体需求、开发与维护成本以及预期的控制精度。通常，小型或初期项目可能更倾向于使用注解或简单配置，而中大型项目则可能需要更细粒度的控制，如通过<code>CorsFilter</code>或nginx配置来满足复杂的跨域需求。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
